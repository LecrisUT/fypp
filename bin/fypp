#!/usr/bin/env python3
################################################################################
#
# fypp -- Fortran preprocessor with Python expression evaluation
#
# Copyright (c) 2016, BÃ¡lint Aradi
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
################################################################################
import builtins
import re
import os

__all__ = [ 'STDIN', 'DirectiveParser', 'TreeBuilder', 'Renderer', 'Evaluator',
            'Processor' ]

STDIN = '<stdin>'

_FILEOBJ = '<fileobj>'

_DIRECTIVE_REGEXP = re.compile(r'''^\s*#(?P<dir>\w+)\s*(?P<param>.*?)?\s*$''')

_MARCO_PARAM_REGEXP = re.compile(
    r'''^(?P<name>\w+)\((?P<args>\s*(?:\w+\s*,\s*)*(?:\w+)\s*)\)$''')

_SETVAR_PARAM_REGEXP = re.compile(r'''^(?P<name>\w+)\s*(?P<expr>.*)?\s*$''')

_SUBST_REGEXP = re.compile(r'''\$\{\s*(?P<expr>.*?)\s*\}\$''')

_FOR_PARAM_REGEXP = re.compile(
    r'''^(?P<loopexpr>\w+(\s*,\s*\w+)*)\s+in\s+(?P<iter>.+)\s*$''')

_INCLUDE_PARAM_REGEXP = re.compile(r'''^(\'|')(?P<fname>.*)\1\s*$''')

_MACRO_CALL_REGEXP = re.compile(
    r'''^\s*@(?P<name>\w+)\(\s*(?P<args>.*)\s*\)\s*$''')

_RESERVED_PREFIX = '_'

_MACRO_PREFIX = '_macro_'


class DirectiveParser:

    def __init__(self, includedirs=None):
        if includedirs is None:
            self._includedirs = []
        else:
            self._includedirs = includedirs
        self._curfile = None
        self._curdir = None


    def parse(self, fobj):
        closefile = False
        if isinstance(fobj, str):
            if fobj == STDIN:
                fp = sys.stdin
                self._curfile = fobj
                self._curdir = os.getcwd()
            else:
                fp = open(fobj, 'r')
                closefile = True
                self._curfile = fobj
                self._curdir = os.path.dirname(fobj)
        else:
            fp = fobj
            self._curfile = _FILEOBJ
            self._curdir = None
        self.handle_open_file(self._curfile, 0)
        self._parse_lines(fp)
        if closefile:
            fp.close()

    
    def handle_open_file(self, fname, linenr):
        print('OPEN FILE:', fname, linenr)

        
    def handle_setvar(self, linenr, name, expr):
        print('SETVAR:{}:'.format(linenr))
        print('  EXPR: |{}|'.format(expr))

    
    def handle_def(self, linenr, name, args):
        print('MACRO:{}:'.format(linenr))
        print('  NAME: |{}|'.format(name))
        print('  ARGS:', args)


    def handle_enddef(self, linenr):
        print('ENDDEF :{}:'.format(linenr))


    def handle_if(self, linenr, param):
        print('IF :{}:'.format(linenr))
        print('  PARAM: |{}|'.format(param))


    def handle_elif(self, linenr, param):
        print('ELIF :{}:'.format(linenr))
        print('  PARAM: |{}|'.format(param))


    def handle_else(self, linenr):
        print('ELSE :{}:'.format(linenr))

        
    def handle_endif(self, linenr):
        print('ENDIF :{}:'.format(linenr))


    def handle_for(self, linenr, varexpr, iterator):
        print('FOR :{}:'.format(linenr))
        print('  VAREXPR: |{}|'.format(varexpr))
        print('  ITERATOR: |{}|'.format(iterator))


    def handle_endfor(self, linenr):
        print('ENDFOR :{}:'.format(linenr))


    def handle_macro_call(self, linenr, name, args):
        print('MACRO CALL: :{}:'.format(linenr))
        print('  NAME: |{}|'.format(name))
        print('  ARGS: |{}|'.format(args))


    def handle_substitution(self, linenr, expr):
        print('SUBS: :{}:'.format(linenr))
        print('  EXPR: |{}|'.format(expr))


    def handle_text(self, txt):
        print('TEXT: {}'.format(txt))


    def _parse_lines(self, fp):
        for linenr, line in enumerate(fp):
            done = self._process_directives(line, linenr)
            if not done:
                done = self._process_macro_call(line, linenr)
            if not done:
                self._process_substitutions(line, linenr)
                
        
    def _process_directives(self, line, linenr):
        match = _DIRECTIVE_REGEXP.search(line)
        if match:
            directive = match.group('dir')
            param = match.group('param')
            if directive == 'if':
                self.handle_if(linenr, param)
            elif directive == 'else':
                self.handle_else(linenr)
            elif directive == 'elif':
                param = match.group('param')
                self.handle_elif(linenr, param)
            elif directive == 'endif':
                self.handle_endif(linenr)
            elif directive == 'def':
                self._process_def(linenr, param)
            elif directive == 'enddef':
                self.handle_enddef(linenr)
            elif directive == 'setvar':
                self._process_setvar(linenr, param)
            elif directive == 'for':
                self._process_for(linenr, param)
            elif directive == 'endfor':
                self.handle_endfor(linenr)
            elif directive == 'include':
                self._process_include(linenr, param)
            else:
                print('<<< UNKNOWN DIRECTIVE:', directive)
            return True
        else:
            return False

            
    def _process_macro_call(self, line, linenr):
        match = _MACRO_CALL_REGEXP.search(line)
        if match:
            self.handle_macro_call(linenr, match.group('name'),
                                   match.group('args'))
            return True
        else:
            return False


    def _process_substitutions(self, line, linenr):
        pos = 0
        for match in _SUBST_REGEXP.finditer(line):
            start = match.start()
            if start > pos:
                self.handle_text(line[pos:start])
            expr = match.group('expr')
            self.handle_substitution(linenr, expr)
            pos = match.end()
        if pos < len(line):
            self.handle_text(line[pos:])


    def _process_def(self, linenr, param):
        match = _MARCO_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID MACRODEF', param)
        name = match.group('name')
        argstr = match.group('args')
        args = [s.strip() for s in argstr.split(',')]
        self.handle_def(linenr, name, args)
        

    def _process_setvar(self, linenr, param):
        match = _SETVAR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID SETVAR', param)
        self.handle_setvar(linenr, match.group('name'),
                           match.group('expr'))

    def _process_for(self, linenr, param):
        match = _FOR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FORDEF')
        loopexpr = match.group('loopexpr')
        loopvars = [s.strip() for s in loopexpr.split(',')]
        self.handle_for(linenr, loopvars, match.group('iter'))

        
    def _process_include(self, linenr, param):
        if self._curdir is None:
            print('<<< Include not allowed when reading from file like object')
            return
        match = _INCLUDE_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FILE NAME')
            return
        fname = match.group('fname')
        for incdir in [ self._curdir ] + self._includedirs:
            fpath = os.path.join(incdir, fname)
            if os.path.exists(fpath):
                break
        else:
            print("<<< INCLUDE FILE '{}' NOT FOUND".format(fname))
            return
        oldfile = self._curfile
        self.parse(fpath)
        self._curfile = oldfile
        self.handle_open_file(self._curfile, linenr)


class TreeBuilder:

    def __init__(self):
        self._tree = []
        self._path = []
        self._open_blocks = []
        self._curnode = self._tree
        self._files = {}
        self._curfile = None

        
    def handle_open_file(self, fname, linenr):
        self._curfile = self._files.get(fname, None)
        if self._curfile is None:
            self._curfile = len(self._files)
            self._files[fname] = self._curfile
        self._curnode.append(('include', linenr, fname))


    def handle_if(self, linenr, cond):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('if', [linenr], [cond], []))


    def handle_elif(self, linenr, cond):
        block = self._open_blocks[-1]
        block[1].append(linenr)
        block[2].append(cond)
        block[3].append(self._curnode)
        self._curnode = []


    def handle_else(self, linenr):
        block = self._open_blocks[-1]
        block[1].append(linenr)
        block[2].append('True')
        block[3].append(self._curnode)
        self._curnode = []


    def handle_endif(self, linenr):
        block = self._open_blocks.pop(-1)
        block[1].append(linenr)
        block[3].append(self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_def(self, linenr, name, args):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('macrodef', [linenr], name, args, None))


    def handle_enddef(self, linenr):
        directive, linenrs, name, args, dummy = self._open_blocks.pop(-1)
        linenrs.append(linenr)
        block = (directive, linenrs, name, args, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_for(self, linenr, loopvar, iterator):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('for', [linenr], loopvar, iterator, None))
        

    def handle_endfor(self, linenr):
        directive, linenrs, loopvar, iterator, dummy = self._open_blocks.pop(-1)
        linenrs.append(linenr)
        block = (directive, linenrs, loopvar, iterator, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_macro_call(self, linenr, name, argstr):
        self._curnode.append(('macrocall', linenr, name, argstr))
        

    def handle_setvar(self, linenr, name, expr):
        self._curnode.append(('setvar', linenr, name, expr))


    def handle_substitution(self, linenr, expr):
        self._curnode.append(('subs', linenr, expr))
        

    def handle_text(self, txt):
        self._curnode.append(('txt', txt))


    @property
    def tree(self):
        return self._tree


class Renderer:
    
    def __init__(self, evaluator=None):
        self._evaluator = Evaluator() if evaluator is None else evaluator
        self._curfile = None
        self._active_macros = 0


    def render(self, tree, env=None):
        newscope = env is not None
        if newscope:
            self._evaluator.pushenv(env)
        output = []
        for node in tree:
            cmd = node[0]
            result = None
            if cmd == 'txt':
                result = [ node[1] ]
            elif cmd == 'if':
                linenrs, conditions, contents = node[1:4]
                result = self._get_conditional_content(conditions, contents,
                                                       linenrs)
            elif cmd == 'subs':
                linenr, expr = node[1:3]
                result = self._get_substituted_content(expr, linenr)
            elif cmd == 'macrodef':
                linenrs, name, args, content = node[1:5]
                result = self._define_macro(name, args, content, linenrs)
            elif cmd == 'macrocall':
                linenr, name, argstr = node[1:4]
                result = self._call_macro(name, argstr, linenr)
            elif cmd == 'setvar':
                linenr, name, content = node[1:4]
                result = self._define_variable(name, content, linenr)
            elif cmd == 'for':
                linenr, loopvars, loopiter, content = node[1:5]
                result = self._get_iterated_content(loopvars, loopiter, 
                                                    content, linenr)
            elif cmd == 'include':
                linenr, fname = node[1:3]
                output += self._register_file(fname, linenr)
            else:
                result = [ '<<<< INVALID LINE |', cmd,  '|\n' ]
            if result is not None:
                output += result
        if newscope:
            self._evaluator.popenv()
        return output


    def _get_substituted_content(self, expr, linenr):
        self._update_linenr(linenr)
        subs = str(self._evaluator.evaluate(expr))
        if subs.count('\n'):
            print('<<< MULTILINE SUBSTITUTION, SYNCLINES PROBABLY INCORRECT')
        return [ subs ]
        

    def _get_conditional_content(self, conditions, contents, linenrs):
        result = []
        for linenr, condition, content in zip(linenrs, conditions, contents):
            self._update_linenr(linenr)
            if self._evaluator.evaluate(condition):
                if not self._active_macros:
                    result.append(_linedirective(linenr + 1, self._curfile))
                result += self.render(content)
                break
        if not self._active_macros:
            result.append(_linedirective(linenrs[-1] + 1, self._curfile))
        return result


    def _get_iterated_content(self, loopvars, loopiter, content, linenrs):
        result = []
        self._update_linenr(linenrs[0])
        iterobj = iter(self._evaluator.evaluate(loopiter))
        for var in iterobj:
            if len(loopvars) == 1:
                loopscope = {loopvars[0]: var}
            else:
                loopscope = {varname: value 
                             for varname, value in zip(loopvars, var)}
            if not self._active_macros:
                result.append(_linedirective(linenrs[0] + 1, self._curfile))
            result += self.render(content, loopscope)
        if not self._active_macros:
            result.append(_linedirective(linenrs[1] + 1, self._curfile))
        return result


    def _define_macro(self, name, args, content, linenrs):
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID MARCO NAME')
        macro = _Macro(args, content, self.render)
        self._evaluator.define(_MACRO_PREFIX + name, macro)
        if not self._active_macros:
            result = [_linedirective(linenrs[1] + 1, self._curfile)]
        else:
            result = []
        return result


    def _define_variable(self, name, valstr, linenr):
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID VARIABLE NAME')
            return
        self._update_linenr(linenr)
        value = self._evaluator.evaluate(valstr)
        self._evaluator.define(name, value)
        if not self._active_macros:
            result = [_linedirective(linenr + 1, self._curfile)]
        else:
            result = []
        return result


    def _call_macro(self, name, argstr, linenr):
        expr = '{}{}({})'.format(_MACRO_PREFIX, name, argstr)
        self._update_linenr(linenr)
        self._active_macros += 1
        output = self._evaluator.evaluate(expr)
        self._active_macros -= 1
        if not self._active_macros:
            output_directives = []
            for token in output[:-1]:
                output_directives.append(token)
                if token.endswith('\n'):
                    output_directives.append(_linedirective(linenr,
                                                            self._curfile))
            output_directives.append(output[-1])
            return output_directives
        else:
            return output


    def _register_file(self, fname, linenr):
        self._curfile = fname
        self._evaluator.updateenv(__FILE__=fname)
        if not self._active_macros:
            return [_linedirective(linenr, self._curfile)]
        else:
            return []


    def _update_linenr(self, linenr):
        if not self._active_macros:
            self._evaluator.updateenv(__LINE__=linenr + 1) 


class Evaluator:

    ALLOWED_BUILTINS = {
        'str': builtins.str,
        'range': builtins.range,
        'type': builtins.type,
    }

    def __init__(self, env=None):
        self._env = env.copy() if env is not None else {}
        self._envstack = []
        builtins = {}
        builtins.update(self.ALLOWED_BUILTINS)
        builtins['defined'] = self._func_defined
        self._builtins = {'__builtins__': builtins}


    def evaluate(self, expr):
        result = eval(expr, self._builtins, self._env)
        return result


    def define(self, name, value):
        self._env[name] = value

    
    def updateenv(self, **vardict):
        self._env.update(vardict)


    def pushenv(self, vardict):
        self._envstack.append(self._env)
        self._env = self._env.copy()
        self._env.update(vardict)


    def popenv(self):
        self._env = self._envstack.pop(-1)


    def _func_defined(self, var):
        return var in self._env

        
class _Macro:

    def __init__(self, argnames, content, renderfunc):
        self.argnames = argnames
        self.content = content
        self.renderfunc = renderfunc


    def __call__(self, *args, **keywords):
        if len(args) != len(self.argnames):
            print('<<< INVALID NR OF ARGS')
        argdict = {}
        for argname, arg in zip(self.argnames, args):
            argdict[argname] = arg
        argdict.update(keywords)
        output = self.renderfunc(self.content, argdict)
        return output


class Processor:

    def __init__(self, parser=None, builder=None, renderer=None, 
                 evaluator=None):
        self._parser = DirectiveParser() if parser is None else parser
        self._builder = TreeBuilder() if builder is None else builder
        if renderer is None:
            evaluator = Evaluator() if evaluator is None else evaluator
            self._renderer = Renderer(evaluator)
        else:
            self._renderer = renderer

        self._parser.handle_open_file = self._builder.handle_open_file
        self._parser.handle_if = self._builder.handle_if
        self._parser.handle_else = self._builder.handle_else
        self._parser.handle_elif = self._builder.handle_elif
        self._parser.handle_endif = self._builder.handle_endif
        self._parser.handle_substitution = self._builder.handle_substitution
        self._parser.handle_text = self._builder.handle_text
        self._parser.handle_def = self._builder.handle_def
        self._parser.handle_enddef = self._builder.handle_enddef
        self._parser.handle_setvar = self._builder.handle_setvar
        self._parser.handle_for = self._builder.handle_for
        self._parser.handle_endfor = self._builder.handle_endfor
        self._parser.handle_macro_call = self._builder.handle_macro_call


    def process(self, fname, env=None):
        self._parser.parse(fname)
        env = {} if env is None else env
        output = self._renderer.render(self._builder.tree, env)
        return ''.join(output)
        

            
def _linedirective(linenr, fname):
    return '# {} "{}"\n'.format(linenr + 1, fname)


################################################################################
# Command line tool fypp
################################################################################

_FYPP_DESC = '''Preprocess Fortran files with FyPP directives.'''


def _fypp_main():
    parser = ArgumentParser(description=_FYPP_DESC)
    args = _fypp_parse_arguments(parser)
    evaluator = Evaluator()
    if args.defines:
        _fypp_apply_definitions(args.defines, evaluator, parser.error)
    parser = DirectiveParser(args.includes)
    builder = TreeBuilder()
    renderer = Renderer(evaluator)
    preprocessor = Processor(parser, builder, renderer)
    _fypp_process_file(preprocessor, args.infile, args.outfile)


def _fypp_parse_arguments(parser):
    msg = 'define a variable with given value. The value is interpreted as ' \
          'Python expression. (e.g `-D DEBUG=1\' sets variable DEBUG to 1). ' \
          'If the value is ommited (e.g. `-D DEBUG\') the variable is set to ' \
          'None.'
    parser.add_argument('-D', '--define', action='append', dest='defines',
                        metavar='VAR=VALUE', help=msg)
    msg = 'add a directory to the search paths, which are looked up when ' \
          'processing include directives. '
    parser.add_argument('-I', '--include', action='append', dest='includes',
                        metavar='INCDIR', help=msg)
    msg = "input file to be processed (default: `-', read from stdin)"
    parser.add_argument('infile', nargs='?', default='-', help=msg)
    msg = "output file where processed content will be written (default: " \
          "`-', written to stdout)"
    parser.add_argument('outfile', nargs='?', default='-', help=msg)
    return parser.parse_args()


def _fypp_apply_definitions(defines, evaluator, errorfunc):

    for define in defines:
        words = define.split('=', 2)
        name = words[0]
        value = None
        if len(words) > 1:
            try:
                value = evaluator.evaluate(words[1])
            except Exception as ex:
                msg = "Exception at evaluating `{}' in definition for `{}':\n" \
                      "{}".format(words[1], words[0], ex)
                errorfunc(msg)
        evaluator.define(name, value)


def _fypp_process_file(preprocessor, infile, outfile):
    if infile == '-':
        infile = STDIN
    output = preprocessor.process(infile)
    if outfile == '-':
        fp = sys.stdout
    else:
        fp = open(outfile, 'w')
    fp.write(output)
    if outfile != '-':
        fp.close()


if __name__ == '__main__':
    import sys
    from argparse import ArgumentParser
    _fypp_main()

