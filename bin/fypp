#!/usr/bin/env python3
################################################################################
#
# fypp -- Fortran preprocessor with Python expression evaluation
#
# Copyright (c) 2016, BÃ¡lint Aradi
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# 'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
################################################################################
import builtins
import re


DIRECTIVE_REGEXP = re.compile(r'''^\s*#(?P<dir>\w+)\s*(?P<param>.*?)?\s*$''')

MARCO_PARAM_REGEXP = re.compile(
    r'''^(?P<name>\w+)\((?P<args>\s*(?:\w+\s*,\s*)*(?:\w+)\s*)\)$''')

SETVAR_PARAM_REGEXP = re.compile(r'''^(?P<name>\w+)\s*(?P<expr>.*)?\s*$''')

SUBST_REGEXP = re.compile(r'''\$\{\s*(?P<expr>.*?)\s*\}\$''')

FOR_PARAM_REGEXP = re.compile(
    r'''^(?P<loopexpr>\w+(\s*,\s*\w+)*)\s+in\s+(?P<iter>.+)\s*$''')

INCLUDE_PARAM_REGEXP = re.compile(r'''^(\'|')(?P<fname>.*)\1\s*$''')

MACRO_CALL_REGEXP = re.compile(
    r'''^\s*@(?P<name>\w+)\(\s*(?P<args>.*)\s*\)\s*$''')

RESERVED_PREFIX = '_'

MACRO_PREFIX = '_macro_'


class DirectiveParser:

    def __init__(self):
        self._fname_stack = []


    def parse(self, fname):
        self._curfile = fname
        self.handle_open_file(self._curfile, 0)
        fp = open(fname, 'r')
        enumerated_lines = enumerate(fp)
        #self._parse_lines(enumerated_lines)
        self._parse_lines(fp)
        fp.close()

    
    def handle_open_file(self, fname, linenr):
        print('OPEN FILE:', fname, linenr)

        
    def handle_setvar(self, linenr, name, expr):
        print('SETVAR:{}:'.format(linenr))
        print('  EXPR: |{}|'.format(expr))

    
    def handle_def(self, linenr, name, args):
        print('MACRO:{}:'.format(linenr))
        print('  NAME: |{}|'.format(name))
        print('  ARGS:', args)


    def handle_enddef(self, linenr):
        print('ENDDEF :{}:'.format(linenr))


    def handle_if(self, linenr, param):
        print('IF :{}:'.format(linenr))
        print('  PARAM: |{}|'.format(param))


    def handle_elif(self, linenr, param):
        print('ELIF :{}:'.format(linenr))
        print('  PARAM: |{}|'.format(param))


    def handle_else(self, linenr):
        print('ELSE :{}:'.format(linenr))

        
    def handle_endif(self, linenr):
        print('ENDIF :{}:'.format(linenr))


    def handle_for(self, linenr, varexpr, iterator):
        print('FOR :{}:'.format(linenr))
        print('  VAREXPR: |{}|'.format(varexpr))
        print('  ITERATOR: |{}|'.format(iterator))


    def handle_endfor(self, linenr):
        print('ENDFOR :{}:'.format(linenr))


    def handle_macro_call(self, linenr, name, args):
        print('MACRO CALL: :{}:'.format(linenr))
        print('  NAME: |{}|'.format(name))
        print('  ARGS: |{}|'.format(args))


    def handle_substitution(self, linenr, expr):
        print('SUBS: :{}:'.format(linenr))
        print('  EXPR: |{}|'.format(expr))


    def handle_text(self, txt):
        print('TEXT: {}'.format(txt))


    def _parse_lines(self, fp):
        for linenr, line in enumerate(fp):
            done = self._process_directives(line, linenr)
            if not done:
                done = self._process_macro_call(line, linenr)
            if not done:
                self._process_substitutions(line, linenr)
                
        
    def _process_directives(self, line, linenr):
        match = DIRECTIVE_REGEXP.search(line)
        if match:
            directive = match.group('dir')
            param = match.group('param')
            if directive == 'if':
                self.handle_if(linenr, param)
            elif directive == 'else':
                self.handle_else(linenr)
            elif directive == 'elif':
                param = match.group('param')
                self.handle_elif(linenr, param)
            elif directive == 'endif':
                self.handle_endif(linenr)
            elif directive == 'def':
                self._process_def(linenr, param)
            elif directive == 'enddef':
                self.handle_enddef(linenr)
            elif directive == 'setvar':
                self._process_setvar(linenr, param)
            elif directive == 'for':
                self._process_for(linenr, param)
            elif directive == 'endfor':
                self.handle_endfor(linenr)
            elif directive == 'include':
                self._process_include(linenr, param)
            else:
                print('<<< UNKNOWN DIRECTIVE:', directive)
            return True
        else:
            return False

            
    def _process_macro_call(self, line, linenr):
        match = MACRO_CALL_REGEXP.search(line)
        if match:
            self.handle_macro_call(linenr, match.group('name'),
                                   match.group('args'))
            return True
        else:
            return False


    def _process_substitutions(self, line, linenr):
        pos = 0
        for match in SUBST_REGEXP.finditer(line):
            start = match.start()
            if start > pos:
                self.handle_text(line[pos:start])
            expr = match.group('expr')
            self.handle_substitution(linenr, expr)
            pos = match.end()
        if pos < len(line):
            self.handle_text(line[pos:])


    def _process_def(self, linenr, param):
        match = MARCO_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID MACRODEF', param)
        name = match.group('name')
        argstr = match.group('args')
        args = [s.strip() for s in argstr.split(',')]
        self.handle_def(linenr, name, args)
        

    def _process_setvar(self, linenr, param):
        match = SETVAR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID SETVAR', param)
        self.handle_setvar(linenr, match.group('name'),
                           match.group('expr'))

    def _process_for(self, linenr, param):
        match = FOR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FORDEF')
        loopexpr = match.group('loopexpr')
        loopvars = [s.strip() for s in loopexpr.split(',')]
        self.handle_for(linenr, loopvars, match.group('iter'))

        
    def _process_include(self, linenr, param):
        match = INCLUDE_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FILE NAME')
        oldfile = self._curfile
        self.parse(match.group('fname'))
        self._curfile = oldfile
        self.handle_open_file(self._curfile, linenr)


class TreeBuilder:

    def __init__(self, parser=None):
        if parser is None:
            self._parser = DirectiveParser()
        else:
            self._parser = parser
        self._parser.handle_open_file = self.handle_open_file
        self._parser.handle_if = self.handle_if
        self._parser.handle_else = self.handle_else
        self._parser.handle_elif = self.handle_elif
        self._parser.handle_endif = self.handle_endif
        self._parser.handle_substitution = self.handle_substitution
        self._parser.handle_text = self.handle_text
        self._parser.handle_def = self.handle_def
        self._parser.handle_enddef = self.handle_enddef
        self._parser.handle_setvar = self.handle_setvar
        self._parser.handle_for = self.handle_for
        self._parser.handle_endfor = self.handle_endfor
        self._parser.handle_macro_call = self.handle_macro_call
        self._tree = []
        self._path = []
        self._open_blocks = []
        self._curnode = self._tree
        self._files = {}
        self._curfile = None

        
    def build_from(self, fname):
        self._parser.parse(fname)


    def handle_open_file(self, fname, linenr):
        self._curfile = self._files.get(fname, None)
        if self._curfile is None:
            self._curfile = len(self._files)
            self._files[fname] = self._curfile
        self._curnode.append(('include', linenr, fname))


    def handle_if(self, linenr, cond):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('if', [linenr], [cond], []))


    def handle_elif(self, linenr, cond):
        block = self._open_blocks[-1]
        block[1].append(linenr)
        block[2].append(cond)
        block[3].append(self._curnode)
        self._curnode = []


    def handle_else(self, linenr):
        block = self._open_blocks[-1]
        block[1].append(linenr)
        block[2].append('True')
        block[3].append(self._curnode)
        self._curnode = []


    def handle_endif(self, linenr):
        block = self._open_blocks.pop(-1)
        block[1].append(linenr)
        block[3].append(self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_def(self, linenr, name, args):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('macrodef', [linenr], name, args, None))


    def handle_enddef(self, linenr):
        directive, linenrs, name, args, dummy = self._open_blocks.pop(-1)
        linenrs.append(linenr)
        block = (directive, linenrs, name, args, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_for(self, linenr, loopvar, iterator):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('for', [linenr], loopvar, iterator, None))
        

    def handle_endfor(self, linenr):
        directive, linenrs, loopvar, iterator, dummy = self._open_blocks.pop(-1)
        linenrs.append(linenr)
        block = (directive, linenrs, loopvar, iterator, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_macro_call(self, linenr, name, argstr):
        self._curnode.append(('macrocall', linenr, name, argstr))
        

    def handle_setvar(self, linenr, name, expr):
        self._curnode.append(('setvar', linenr, name, expr))


    def handle_substitution(self, linenr, expr):
        self._curnode.append(('subs', linenr, expr))
        

    def handle_text(self, txt):
        self._curnode.append(('txt', txt))


    @property
    def tree(self):
        return self._tree


class Renderer:
    
    def __init__(self):
        self._evaluator = Evaluator()
        self._curfile = None
        self._active_macros = 0

    def render(self, tree, env=None):
        newscope = env is not None
        if newscope:
            self._evaluator.pushenv(env)
        output = []
        for node in tree:
            cmd = node[0]
            #print("NODE:", node)
            result = None
            if cmd == 'txt':
                result = [ node[1] ]
            elif cmd == 'if':
                linenrs, conditions, contents = node[1:4]
                result = self._get_conditional_content(conditions, contents,
                                                       linenrs)
            elif cmd == 'subs':
                linenr, expr = node[1:3]
                result = self._get_substituted_content(expr, linenr)
            elif cmd == 'macrodef':
                linenrs, name, args, content = node[1:5]
                result = self._define_macro(name, args, content, linenrs)
            elif cmd == 'macrocall':
                linenr, name, argstr = node[1:4]
                result = self._call_macro(name, argstr, linenr)
            elif cmd == 'setvar':
                linenr, name, content = node[1:4]
                result = self._define_variable(name, content, linenr)
            elif cmd == 'for':
                linenr, loopvars, loopiter, content = node[1:5]
                result = self._get_iterated_content(loopvars, loopiter, 
                                                    content, linenr)
            elif cmd == 'include':
                linenr, fname = node[1:3]
                output += self._register_file(fname, linenr)
            else:
                result = [ '<<<< INVALID LINE |', cmd,  '|\n' ]
            if result is not None:
                output += result
        if newscope:
            self._evaluator.popenv()
        return output


    def _get_substituted_content(self, expr, linenr):
        self._update_linenr(linenr)
        subs = str(self._evaluator.evaluate(expr))
        if subs.count('\n'):
            print('<<< MULTILINE SUBSTITUTION, SYNCLINES PROBABLY INCORRECT')
        return [ subs ]
        

    def _get_conditional_content(self, conditions, contents, linenrs):
        result = []
        for linenr, condition, content in zip(linenrs, conditions, contents):
            self._update_linenr(linenr)
            if self._evaluator.evaluate(condition):
                if not self._active_macros:
                    result.append(linedirective(linenr + 1, self._curfile))
                result += self.render(content)
                break
        if not self._active_macros:
            result.append(linedirective(linenrs[-1] + 1, self._curfile))
        return result


    def _get_iterated_content(self, loopvars, loopiter, content, linenrs):
        result = []
        self._update_linenr(linenrs[0])
        iterobj = iter(self._evaluator.evaluate(loopiter))
        for var in iterobj:
            if len(loopvars) == 1:
                loopscope = {loopvars[0]: var}
            else:
                loopscope = {varname: value 
                             for varname, value in zip(loopvars, var)}
            if not self._active_macros:
                result.append(linedirective(linenrs[0] + 1, self._curfile))
            result += self.render(content, loopscope)
        if not self._active_macros:
            result.append(linedirective(linenrs[1] + 1, self._curfile))
        return result


    def _define_macro(self, name, args, content, linenrs):
        if name.startswith(RESERVED_PREFIX):
            print('<<< INVALID MARCO NAME')
        macro = Macro(args, content, self.render)
        self._evaluator.define(MACRO_PREFIX + name, macro)
        if not self._active_macros:
            result = [ linedirective(linenrs[1] + 1, self._curfile) ]
        else:
            result = []
        return result


    def _define_variable(self, name, valstr, linenr):
        if name.startswith(RESERVED_PREFIX):
            print('<<< INVALID VARIABLE NAME')
            return
        self._update_linenr(linenr)
        value = self._evaluator.evaluate(valstr)
        self._evaluator.define(name, value)
        if not self._active_macros:
            result = [ linedirective(linenr + 1, self._curfile) ]
        else:
            result = []
        return result


    def _call_macro(self, name, argstr, linenr):
        expr = '{}{}({})'.format(MACRO_PREFIX, name, argstr)
        self._update_linenr(linenr)
        self._active_macros += 1
        output = self._evaluator.evaluate(expr)
        self._active_macros -= 1
        if not self._active_macros:
            output_directives = []
            for token in output[:-1]:
                output_directives.append(token)
                if token.endswith('\n'):
                    output_directives.append(linedirective(linenr, 
                                                           self._curfile))
            output_directives.append(output[-1])
            return output_directives
        else:
            return output


    def _register_file(self, fname, linenr):
        self._curfile = fname
        self._evaluator.updateenv(__FILE__=fname)
        if not self._active_macros:
            return [ linedirective(linenr, self._curfile) ]
        else:
            return []


    def _update_linenr(self, linenr):
        if not self._active_macros:
            self._evaluator.updateenv(__LINE__=linenr + 1) 


class Evaluator:

    ALLOWED_BUILTINS = {
        'str': builtins.str,
        'range': builtins.range,
        'type': builtins.type,
    }

    def __init__(self, env=None):
        self._env = env.copy() if env is not None else {}
        self._envstack = []
        builtins = {}
        builtins.update(self.ALLOWED_BUILTINS)
        builtins['defined'] = self._func_defined
        self._builtins = {'__builtins__': builtins}


    def evaluate(self, expr):
        result = eval(expr, self._builtins, self._env)
        return result


    def define(self, name, value):
        self._env[name] = value

    
    def updateenv(self, **vardict):
        self._env.update(vardict)


    def pushenv(self, vardict):
        self._envstack.append(self._env)
        self._env = self._env.copy()
        self._env.update(vardict)


    def popenv(self):
        self._env = self._envstack.pop(-1)


    def _func_defined(self, var):
        return var in self._env

        
class Macro:

    def __init__(self, argnames, content, renderfunc):
        self.argnames = argnames
        self.content = content
        self.renderfunc = renderfunc


    def __call__(self, *args, **keywords):
        if len(args) != len(self.argnames):
            print('<<< INVALID NR OF ARGS')
        argdict = {}
        for argname, arg in zip(self.argnames, args):
            argdict[argname] = arg
        argdict.update(keywords)
        output = self.renderfunc(self.content, argdict)
        return output

            
def linedirective(linenr, fname):
    return '# {} "{}"\n'.format(linenr + 1, fname)


if __name__ == '__main__':
    builder = TreeBuilder()
    builder.build_from('test.F90')
    myenv = {'WITH_MPI': None, 'WITH_OPENMP': None}
    renderer = Renderer()
    output = renderer.render(builder.tree, myenv)
    #print(builder.tree)
    print(''.join(output))
