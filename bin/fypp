#!/usr/bin/env python3
################################################################################
#
# fypp -- Fortran preprocessor with Python expression evaluation
#
# Copyright (c) 2016, BÃ¡lint Aradi
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################################
import builtins
import re
import os

__all__ = [ 'STDIN', 'DirectiveParser', 'TreeBuilder', 'Renderer', 'Evaluator',
            'Processor' ]

STDIN = '<stdin>'

_FILEOBJ = '<fileobj>'

_DIRECTIVE_REGEXP = re.compile(r'''
# directive name
^[ \t]*\#(?P<directive>\w+)[ \t]*
# directive parameter (with optional continuation lines)
(?P<param>.*?(?:&[ \t]*\n[ \t]*&.*?)*)?[ \t]*\n
|
# macro name
^[ \t]*\$(?P<macroname>\w+)
# arguments (with optional continuation lines)
\([ \t]*(?P<args>.*?(?:&[ \t]*\n[ \t]*&.*?)*)[ \t]*\)[ \t]*\n
|
# subsitution
\$\{[ \t]*(?P<expr>.*?)[ \t]*\}\$
''', re.VERBOSE | re.MULTILINE)

_MARCO_PARAM_REGEXP = re.compile(
    r'''^(?P<name>\w+)\((?P<args>\s*(?:\w+\s*,\s*)*(?:\w+)\s*)\)$''')

_SETVAR_PARAM_REGEXP = re.compile(r'''^(?P<name>\w+)\s*(?P<expr>.*)?\s*$''')

_FOR_PARAM_REGEXP = re.compile(
    r'''^(?P<loopexpr>\w+(\s*,\s*\w+)*)\s+in\s+(?P<iter>.+)\s*$''')

_INCLUDE_PARAM_REGEXP = re.compile(r'''^(\'|')(?P<fname>.*)\1\s*$''')

_CONTLINE_REGEXP = re.compile(r'''&[ \t]*\n[ \t]*&''')

_RESERVED_PREFIX = '_'

_MACRO_PREFIX = '_macro_'


class DirectiveParser:

    def __init__(self, includedirs=None):
        if includedirs is None:
            self._includedirs = []
        else:
            self._includedirs = includedirs
        self._curfile = None
        self._curdir = None


    def parsefile(self, fobj):
        closefile = False
        if isinstance(fobj, str):
            if fobj == STDIN:
                fp = sys.stdin
                self._curfile = fobj
                self._curdir = os.getcwd()
            else:
                fp = open(fobj, 'r')
                closefile = True
                self._curfile = fobj
                self._curdir = os.path.dirname(fobj)
        else:
            fp = fobj
            self._curfile = _FILEOBJ
            self._curdir = None
        self.handle_open_file(self._curfile, 0)
        self.parse(fp.read())
        if closefile:
            fp.close()


    def parse(self, txt):
        self._parse(txt)

    
    def handle_open_file(self, fname, linenr):
        print('OPEN FILE:', fname, linenr)

        
    def handle_setvar(self, name, expr, span):
        print('SETVAR:{}-{}:'.format(*span))
        print('  EXPR: |{}|'.format(expr))

    
    def handle_def(self, name, args, span):
        print('MACRO:{}-{}:'.format(*span))
        print('  NAME: |{}|'.format(name))
        print('  ARGS:', args)


    def handle_enddef(self, span):
        print('ENDDEF :{}-{}:'.format(*span))


    def handle_if(self, param, span):
        print('IF :{}-{}:'.format(*span))
        print('  PARAM: |{}|'.format(param))


    def handle_elif(self, param, span):
        print('ELIF :{}-{}:'.format(*span))
        print('  PARAM: |{}|'.format(param))


    def handle_else(self, span):
        print('ELSE :{}-{}:'.format(*span))

        
    def handle_endif(self, span):
        print('ENDIF :{}-{}:'.format(*span))


    def handle_for(self, varexpr, iterator, span):
        print('FOR :{}-{}:'.format(*span))
        print('  VAREXPR: |{}|'.format(varexpr))
        print('  ITERATOR: |{}|'.format(iterator))


    def handle_endfor(self, span):
        print('ENDFOR :{}-{}:'.format(*span))


    def handle_macro_call(self, name, args, span):
        print('MACRO CALL: :{}-{}:'.format(*span))
        print('  NAME: |{}|'.format(name))
        print('  ARGS: |{}|'.format(args))


    def handle_substitution(self, expr, span):
        print('SUBS: :{}-{}:'.format(*span))
        print('  EXPR: |{}|'.format(expr))


    def handle_text(self, txt):
        print('TEXT: {}'.format(txt))


    def _parse(self, txt):
        pos = 0
        linenr = 0
        for match in _DIRECTIVE_REGEXP.finditer(txt):
            groups = match.groupdict()
            start, end = match.span()
            if start > pos:
                self.handle_text(txt[pos:start])
                linenr += txt.count('\n', pos, start)
            endlinenr = linenr + txt.count('\n', start, end)
            if groups['directive'] is not None:
                self._process_directive(groups['directive'], groups['param'],
                                        (linenr, endlinenr))
            elif groups['macroname'] is not None:
                self._process_macro_call(groups['macroname'], groups['args'],
                                         (linenr, endlinenr))
            else:
                self._process_substitution(groups['expr'], (linenr, endlinenr))
            pos = end
            linenr = endlinenr
        if pos < len(txt):
            self.handle_text(txt[pos:])


    def _process_directive(self, directive, param, span):
        param = _CONTLINE_REGEXP.sub('', param)
        if directive == 'if':
            self.handle_if(param, span)
        elif directive == 'else':
            self.handle_else(span)
        elif directive == 'elif':
            self.handle_elif(param, span)
        elif directive == 'endif':
            self.handle_endif(span)
        elif directive == 'def':
            self._process_def(param, span)
        elif directive == 'enddef':
            self.handle_enddef(span)
        elif directive == 'setvar':
            self._process_setvar(param, span)
        elif directive == 'for':
            self._process_for(param, span)
        elif directive == 'endfor':
            self.handle_endfor(span)
        elif directive == 'include':
            self._process_include(param, span[1])
        else:
            print('<<< UNKNOWN DIRECTIVE:', directive)

            
    def _process_macro_call(self, name, args, span):
        args = _CONTLINE_REGEXP.sub('', args)
        self.handle_macro_call(name, args, span)


    def _process_substitution(self, expr, span):
        expr = _CONTLINE_REGEXP.sub('', expr)
        self.handle_substitution(expr, span)


    def _process_def(self, param, span):
        match = _MARCO_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID MACRODEF', param)
        name = match.group('name')
        argstr = match.group('args')
        args = [s.strip() for s in argstr.split(',')]
        self.handle_def(name, args, span)
        

    def _process_setvar(self, param, span):
        match = _SETVAR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID SETVAR', param)
        self.handle_setvar(match.group('name'), match.group('expr'), span)


    def _process_for(self, param, span):
        match = _FOR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FORDEF')
        loopexpr = match.group('loopexpr')
        loopvars = [s.strip() for s in loopexpr.split(',')]
        self.handle_for(loopvars, match.group('iter'), span)

        
    def _process_include(self, param, linenr):
        if self._curdir is None:
            print('<<< Include not allowed when reading from file like object')
            return
        match = _INCLUDE_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FILE NAME')
            return
        fname = match.group('fname')
        for incdir in [ self._curdir ] + self._includedirs:
            fpath = os.path.join(incdir, fname)
            if os.path.exists(fpath):
                break
        else:
            print("<<< INCLUDE FILE '{}' NOT FOUND".format(fname))
            return
        oldfile = self._curfile
        self.parsefile(fpath)
        self._curfile = oldfile
        self.handle_open_file(self._curfile, linenr)


class TreeBuilder:

    def __init__(self):
        self._tree = []
        self._path = []
        self._open_blocks = []
        self._curnode = self._tree
        self._files = {}
        self._curfile = None

        
    def handle_open_file(self, fname, linenr):
        self._curfile = self._files.get(fname, None)
        if self._curfile is None:
            self._curfile = len(self._files)
            self._files[fname] = self._curfile
        self._curnode.append(('include', fname, linenr))


    def handle_if(self, cond, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('if', [cond], [], [span]))


    def handle_elif(self, cond, span):
        block = self._open_blocks[-1]
        block[1].append(cond)
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = []


    def handle_else(self, span):
        block = self._open_blocks[-1]
        block[1].append('True')
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = []


    def handle_endif(self, span):
        block = self._open_blocks.pop(-1)
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_def(self, name, args, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('macrodef', name, args, None, [span]))


    def handle_enddef(self, span):
        directive, name, args, dummy, spans = self._open_blocks.pop(-1)
        spans.append(span)
        block = (directive, name, args, self._curnode, spans)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_for(self, loopvar, iterator, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('for', loopvar, iterator, None, [span]))
        

    def handle_endfor(self, span):
        directive, loopvar, iterator, dummy, spans = self._open_blocks.pop(-1)
        spans.append(span)
        block = (directive, loopvar, iterator, self._curnode, spans)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_macro_call(self, name, argstr, span):
        self._curnode.append(('macrocall', name, argstr, span))
        

    def handle_setvar(self, name, expr, span):
        self._curnode.append(('setvar', name, expr, span))


    def handle_substitution(self, expr, span):
        self._curnode.append(('subs', expr, span))
        

    def handle_text(self, txt):
        self._curnode.append(('txt', txt))


    @property
    def tree(self):
        return self._tree


class Renderer:
    
    def __init__(self, evaluator=None, synclines=False):
        self._evaluator = Evaluator() if evaluator is None else evaluator
        self._curfile = None
        self._active_macros = 0
        self._synclines = synclines


    def render(self, tree, env=None):
        newscope = env is not None
        if newscope:
            self._evaluator.pushenv(env)
        output = []
        for node in tree:
            cmd = node[0]
            result = None
            if cmd == 'txt':
                result = node[1]
            elif cmd == 'if':
                result = self._get_conditional_content(*node[1:4])
            elif cmd == 'subs':
                result = self._get_substituted_content(*node[1:3])
            elif cmd == 'macrodef':
                result = self._define_macro(*node[1:5])
            elif cmd == 'macrocall':
                result = self._call_macro(*node[1:4])
            elif cmd == 'setvar':
                result = self._define_variable(*node[1:4])
            elif cmd == 'for':
                result = self._get_iterated_content(*node[1:5])
            elif cmd == 'include':
                result = self._register_file(*node[1:3])
            else:
                result = '<<<< INVALID LINE |' + cmd +  '|\n'
            if result is not None:
                output.append(result)
        if newscope:
            self._evaluator.popenv()
        return ''.join(output)


    def _get_substituted_content(self, expr, span):
        self._update_linenr(span[1])
        subs = str(self._evaluator.evaluate(expr))
        if subs.count('\n'):
            print('<<< Multiline substitution not supported')
        return subs
        

    def _get_conditional_content(self, conditions, contents, spans):
        result = []
        for condition, content, span in zip(conditions, contents, spans):
            self._update_linenr(span[1])
            if self._evaluator.evaluate(condition):
                if self._synclines and not self._active_macros:
                    result.append(_syncline(span[1], self._curfile))
                result.append(self.render(content))
                break
        if self._synclines and not self._active_macros:
            result.append(_syncline(spans[-1][1], self._curfile))
        return ''.join(result)


    def _get_iterated_content(self, loopvars, loopiter, content, spans):
        result = []
        self._update_linenr(spans[0][1])
        iterobj = iter(self._evaluator.evaluate(loopiter))
        for var in iterobj:
            if len(loopvars) == 1:
                loopscope = {loopvars[0]: var}
            else:
                loopscope = {varname: value 
                             for varname, value in zip(loopvars, var)}
            if self._synclines and not self._active_macros:
                result.append(_syncline(spans[0][1], self._curfile))
            result.append(self.render(content, loopscope))
        if self._synclines and not self._active_macros:
            result.append(_syncline(spans[1][1], self._curfile))
        return ''.join(result)


    def _define_macro(self, name, args, content, spans):
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID MARCO NAME')
        macro = _Macro(args, content, self.render)
        self._evaluator.define(_MACRO_PREFIX + name, macro)
        if self._synclines and not self._active_macros:
            return _syncline(spans[1][1], self._curfile)
        else:
            return None


    def _define_variable(self, name, valstr, span):
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID VARIABLE NAME')
            return
        self._update_linenr(span[0])
        value = self._evaluator.evaluate(valstr)
        self._evaluator.define(name, value)
        if self._synclines and not self._active_macros:
            return _syncline(span[1], self._curfile)
        else:
            return None


    def _call_macro(self, name, argstr, span):
        expr = '{}{}({})'.format(_MACRO_PREFIX, name, argstr)
        self._update_linenr(span[0])
        self._active_macros += 1
        out = self._evaluator.evaluate(expr)
        self._active_macros -= 1
        if self._synclines and not self._active_macros:
            out = out.rstrip()
            out = out.replace('\n', '\n' + _syncline(span[0], self._curfile))
            out = out + '\n' + _syncline(span[1], self._curfile)
        return out


    def _register_file(self, fname, line):
        self._curfile = fname
        self._evaluator.updateenv(__FILE__=fname)
        if self._synclines and not self._active_macros:
            return _syncline(line, self._curfile)
        else:
            return None


    def _update_linenr(self, linenr):
        if not self._active_macros:
            self._evaluator.updateenv(__LINE__=linenr + 1) 


class Evaluator:

    ALLOWED_BUILTINS = {
        'str': builtins.str,
        'range': builtins.range,
        'type': builtins.type,
    }

    def __init__(self, env=None):
        self._env = env.copy() if env is not None else {}
        self._envstack = []
        builtins = {}
        builtins.update(self.ALLOWED_BUILTINS)
        builtins['defined'] = self._func_defined
        self._builtins = {'__builtins__': builtins}


    def evaluate(self, expr):
        result = eval(expr, self._builtins, self._env)
        return result


    def define(self, name, value):
        self._env[name] = value

    
    def updateenv(self, **vardict):
        self._env.update(vardict)


    def pushenv(self, vardict):
        self._envstack.append(self._env)
        self._env = self._env.copy()
        self._env.update(vardict)


    def popenv(self):
        self._env = self._envstack.pop(-1)


    def _func_defined(self, var):
        return var in self._env

        
class _Macro:

    def __init__(self, argnames, content, renderfunc):
        self.argnames = argnames
        self.content = content
        self.renderfunc = renderfunc


    def __call__(self, *args, **keywords):
        if len(args) != len(self.argnames):
            print('<<< INVALID NR OF ARGS')
        argdict = {}
        for argname, arg in zip(self.argnames, args):
            argdict[argname] = arg
        argdict.update(keywords)
        output = self.renderfunc(self.content, argdict)
        return output


class Processor:

    def __init__(self, parser=None, builder=None, renderer=None, 
                 evaluator=None):
        self._parser = DirectiveParser() if parser is None else parser
        self._builder = TreeBuilder() if builder is None else builder
        if renderer is None:
            evaluator = Evaluator() if evaluator is None else evaluator
            self._renderer = Renderer(evaluator)
        else:
            self._renderer = renderer

        self._parser.handle_open_file = self._builder.handle_open_file
        self._parser.handle_if = self._builder.handle_if
        self._parser.handle_else = self._builder.handle_else
        self._parser.handle_elif = self._builder.handle_elif
        self._parser.handle_endif = self._builder.handle_endif
        self._parser.handle_substitution = self._builder.handle_substitution
        self._parser.handle_text = self._builder.handle_text
        self._parser.handle_def = self._builder.handle_def
        self._parser.handle_enddef = self._builder.handle_enddef
        self._parser.handle_setvar = self._builder.handle_setvar
        self._parser.handle_for = self._builder.handle_for
        self._parser.handle_endfor = self._builder.handle_endfor
        self._parser.handle_macro_call = self._builder.handle_macro_call


    def process(self, fname, env=None):
        self._parser.parsefile(fname)
        env = {} if env is None else env
        output = self._renderer.render(self._builder.tree, env)
        return ''.join(output)
        

            
def _syncline(linenr, fname):
    return '# {} "{}"\n'.format(linenr + 1, fname)


def _join_continuations(txt):
    nlines = txt.count('\n')
    newtxt = _CONTLINE_REGEXP.sub('', txt)
    return newtxt, nlines



################################################################################
# Command line tool
################################################################################

_FYPP_DESC = '''Preprocess Fortran files with FyPP directives.'''


def _fypp_main():
    parser = ArgumentParser(description=_FYPP_DESC)
    args = _fypp_parse_arguments(parser)
    evaluator = Evaluator()
    if args.defines:
        _fypp_apply_definitions(args.defines, evaluator, parser.error)
    parser = DirectiveParser(args.includes)
    builder = TreeBuilder()
    renderer = Renderer(evaluator, synclines=args.synclines)
    preprocessor = Processor(parser, builder, renderer)
    _fypp_process_file(preprocessor, args.infile, args.outfile)


def _fypp_parse_arguments(parser):
    msg = 'define a variable with given value. The value is interpreted as ' \
          'Python expression. (e.g `-D DEBUG=1\' sets variable DEBUG to 1). ' \
          'If the value is ommited (e.g. `-D DEBUG\') the variable is set to ' \
          'None.'
    parser.add_argument('-D', '--define', action='append', dest='defines',
                        metavar='VAR[=VALUE]', help=msg)
    msg = 'add a directory to the search paths, which are looked up when ' \
          'processing include directives. '
    parser.add_argument('-I', '--include', action='append', dest='includes',
                        metavar='INCDIR', help=msg)
    msg = 'include CPP style sync-lines in the output.'
    parser.add_argument('-s', '--synclines', action='store_true', 
                        default=False, help=msg)
    msg = "input file to be processed (default: `-', read from stdin)"
    parser.add_argument('infile', nargs='?', default='-', help=msg)
    msg = "output file where processed content will be written (default: " \
          "`-', written to stdout)"
    parser.add_argument('outfile', nargs='?', default='-', help=msg)
    return parser.parse_args()


def _fypp_apply_definitions(defines, evaluator, errorfunc):

    for define in defines:
        words = define.split('=', 2)
        name = words[0]
        value = None
        if len(words) > 1:
            try:
                value = evaluator.evaluate(words[1])
            except Exception as ex:
                msg = "Exception at evaluating `{}' in definition for `{}':\n" \
                      "{}".format(words[1], words[0], ex)
                errorfunc(msg)
        evaluator.define(name, value)


def _fypp_process_file(preprocessor, infile, outfile):
    if infile == '-':
        infile = STDIN
    output = preprocessor.process(infile)
    if outfile == '-':
        fp = sys.stdout
    else:
        fp = open(outfile, 'w')
    fp.write(output)
    if outfile != '-':
        fp.close()


if __name__ == '__main__':
    import sys
    from argparse import ArgumentParser
    _fypp_main()

