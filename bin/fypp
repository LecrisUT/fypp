#!/usr/bin/env python3
################################################################################
#
# fypp -- Python powered Fortran preprocessor
#
# Copyright (c) 2016, BÃ¡lint Aradi
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################################
import builtins
import types
import re
import os
import sys
from argparse import ArgumentParser


__all__ = [ 'VERSION', 'DirectiveParser', 'TreeBuilder', 'Renderer', 
            'Evaluator', 'Processor', 'syncline', 'STDIN', 'FILEOBJ', 'STRING' ]

VERSION = '0.1'

STDIN = '<stdin>'

FILEOBJ = '<fileobj>'

STRING = '<string>'


_DIRECTIVE_REGEXP = re.compile(r'''
# comment block
(?P<comment>(?:^[ \t]*@!.*\n)+)
|
# line directive (with optional continuation lines)
^[ \t]*@:[ \t]*(?P<ldirective>\w+)[ \t]*
(?P<lparam>.*?(?:&[ \t]*\n[ \t]*&.*?)*)?[ \t]*\n
|
# line expression evaluation (with optional continuation lines)
^[ \t]*\$:[ \t]*(?P<lexpr>.*?(?:&[ \t]*\n(?:[ \t]*&)?.*?)*)[ \t]*$
|
# inline directive
@\{[ \t]*(?P<idirective>\w+)[ \t]*(?P<param>.*?)?[ \t]*\}@
|
# inline expression evaluation
\$\{[ \t]*(?P<iexpr>.*?)[ \t]*\}\$
''', re.VERBOSE | re.MULTILINE)

_MACRO_PARAM_REGEXP = re.compile(
    r'^(?P<name>\w+)\((?P<args>\s*(?:\w+\s*,\s*)*(?:\w+)\s*)\)$')

_SETVAR_PARAM_REGEXP = re.compile(r'^(?P<name>\w+)\s*(?P<expr>.*)?\s*$')

_FOR_PARAM_REGEXP = re.compile(
    r'^(?P<loopexpr>\w+(\s*,\s*\w+)*)\s+in\s+(?P<iter>.+)\s*$')

_INCLUDE_PARAM_REGEXP = re.compile(r'^(\'|")(?P<fname>.*?)\1\s*$')

_CONTLINE_REGEXP = re.compile(r'&[ \t]*\n(?:[ \t]*&)?')

_RESERVED_PREFIX = '_'


class DirectiveParser:

    def __init__(self, includedirs=None):
        if includedirs is None:
            self._includedirs = []
        else:
            self._includedirs = includedirs
        self._curfile = None
        self._curdir = None


    def parsefile(self, fobj):
        closefile = False
        if isinstance(fobj, str):
            if fobj == STDIN:
                fp = sys.stdin
                self._curfile = fobj
                self._curdir = os.getcwd()
            else:
                fp = open(fobj, 'r')
                closefile = True
                self._curfile = fobj
                self._curdir = os.path.dirname(fobj)
        else:
            fp = fobj
            self._curfile = FILEOBJ
            self._curdir = os.getcwd()
        self.handle_open_file(self._curfile, 0)
        self._parse(fp.read())
        if closefile:
            fp.close()


    def parse(self, txt):
        self._curfile = STRING
        self._curdir = os.getcwd()
        self.handle_open_file(self._curfile, 0)
        self._parse(txt)

    
    def handle_open_file(self, fname, linenr):
        self._log_event('open file', (linenr, linenr), filename=fname)

        
    def handle_setvar(self, name, expr, span):
        self._log_event('setvar', span, name=name, expression=expr)

    
    def handle_def(self, name, args, span):
        self._log_event('def', span, name=name, arguments=args)


    def handle_enddef(self, span):
        self._log_event('enddef', span)


    def handle_if(self, param, span):
        self._log_event('if', span, condition=param)


    def handle_elif(self, param, span):
        self._log_event('elif', span, condition=param)


    def handle_else(self, span):
        self._log_event('else', span)

        
    def handle_endif(self, span):
        self._log_event('endif', span)


    def handle_for(self, varexpr, iterator, span):
        self._log_event('for', span, variable=varexpr, iterable=iterator)


    def handle_endfor(self, span):
        self._log_event('endfor', span)


    def handle_expreval(self, expr, span):
        self._log_event('expreval', span, expression=expr)


    def handle_text(self, txt, span):
        self._log_event('text', span, content=txt)


    def handle_comment(self, span):
        self._log_event('comment', span)


    def handle_mute(self, span):
        self._log_event('mute', span)

    
    def handle_endmute(self, span):
        self._log_event('endmute', span)


    @staticmethod
    def _log_event(event, span, **params):
        print('{}: {}-{}'.format(event, span[0], span[1]))
        for parname, parvalue in params.items():
            print('  {}: ->|{}|<-'.format(parname, parvalue))
        print()

        
    def _parse(self, txt):
        pos = 0
        linenr = 0
        for match in _DIRECTIVE_REGEXP.finditer(txt):
            groups = match.groupdict()
            start, end = match.span()
            if start > pos:
                endlinenr = linenr + txt.count('\n', pos, start)
                self.handle_text(txt[pos:start], (linenr, endlinenr))
                linenr = endlinenr
            endlinenr = linenr + txt.count('\n', start, end)
            if groups['ldirective'] is not None:
                self._process_directive(
                    groups['ldirective'], groups['lparam'], 
                    (linenr, endlinenr))
            elif groups['lexpr'] is not None:
                self._process_lexpreval(groups['lexpr'], (linenr, endlinenr))
            elif groups['idirective'] is not None:
                self._process_directive(groups['idirective'], groups['param'],
                                        (linenr, endlinenr))
            elif groups['iexpr'] is not None:
                self._process_iexpreval(groups['iexpr'], (linenr, endlinenr))
            elif groups['comment'] is not None:
                self.handle_comment((linenr, endlinenr))
            else:
                print('<<< SHOULDNT HAPPEN!', (linenr, endlinenr))
            pos = end
            linenr = endlinenr
        if pos < len(txt):
            endlinenr = linenr + txt.count('\n', pos)
            self.handle_text(txt[pos:], (linenr, endlinenr))


    def _process_directive(self, directive, param, span):
        param = _CONTLINE_REGEXP.sub('', param)
        if directive == 'if':
            self.handle_if(param, span)
        elif directive == 'else':
            self.handle_else(span)
        elif directive == 'elif':
            self.handle_elif(param, span)
        elif directive == 'endif':
            self.handle_endif(span)
        elif directive == 'def':
            self._process_def(param, span)
        elif directive == 'enddef':
            self.handle_enddef(span)
        elif directive == 'setvar':
            self._process_setvar(param, span)
        elif directive == 'for':
            self._process_for(param, span)
        elif directive == 'endfor':
            self.handle_endfor(span)
        elif directive == 'include':
            self._process_include(param, span[1])
        elif directive == 'mute':
            self.handle_mute(span)
        elif directive == 'endmute':
            self.handle_endmute(span)
        else:
            print('<<< UNKNOWN DIRECTIVE:', directive)

            
    def _process_lexpreval(self, expr, span):
        expr = _CONTLINE_REGEXP.sub('', expr)
        self.handle_expreval(expr, span)


    def _process_iexpreval(self, expr, span):
        self.handle_expreval(expr, span)


    def _process_def(self, param, span):
        match = _MACRO_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID MACRODEF', param)
        name = match.group('name')
        argstr = match.group('args')
        args = [s.strip() for s in argstr.split(',')]
        self.handle_def(name, args, span)
        

    def _process_setvar(self, param, span):
        match = _SETVAR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID SETVAR', param)
        self.handle_setvar(match.group('name'), match.group('expr'), span)


    def _process_for(self, param, span):
        match = _FOR_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FORDEF')
        loopexpr = match.group('loopexpr')
        loopvars = [s.strip() for s in loopexpr.split(',')]
        self.handle_for(loopvars, match.group('iter'), span)

        
    def _process_include(self, param, linenr):
        match = _INCLUDE_PARAM_REGEXP.search(param)
        if not match:
            print('<<< INVALID FILE NAME')
            return
        fname = match.group('fname')
        for incdir in [ self._curdir ] + self._includedirs:
            fpath = os.path.join(incdir, fname)
            if os.path.exists(fpath):
                break
        else:
            print("<<< INCLUDE FILE '{}' NOT FOUND".format(fname))
            return
        oldfile = self._curfile
        self.parsefile(fpath)
        self._curfile = oldfile
        self.handle_open_file(self._curfile, linenr)


class TreeBuilder:

    def __init__(self):
        self._tree = []
        self._path = []
        self._open_blocks = []
        self._curnode = self._tree
        self._files = {}
        self._curfile = None


    def reset(self):
        self._tree = []
        self._path = []
        self._open_blocks = []
        self._curnode = self._tree
        self._files = {}
        self._curfile = None


    def handle_open_file(self, fname, linenr):
        self._curfile = self._files.get(fname, None)
        if self._curfile is None:
            self._curfile = len(self._files)
            self._files[fname] = self._curfile
        self._curnode.append(('include', fname, linenr))


    def handle_if(self, cond, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('if', [cond], [], [span]))


    def handle_elif(self, cond, span):
        block = self._open_blocks[-1]
        block[1].append(cond)
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = []


    def handle_else(self, span):
        block = self._open_blocks[-1]
        block[1].append('True')
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = []


    def handle_endif(self, span):
        block = self._open_blocks.pop(-1)
        block[2].append(self._curnode)
        block[3].append(span)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_def(self, name, args, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('macrodef', name, args, None, [span]))


    def handle_enddef(self, span):
        directive, name, args, dummy, spans = self._open_blocks.pop(-1)
        spans.append(span)
        block = (directive, name, args, self._curnode, spans)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_for(self, loopvar, iterator, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('for', loopvar, iterator, None, [span]))
        

    def handle_endfor(self, span):
        directive, loopvar, iterator, dummy, spans = self._open_blocks.pop(-1)
        spans.append(span)
        block = (directive, loopvar, iterator, self._curnode, spans)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_setvar(self, name, expr, span):
        self._curnode.append(('setvar', name, expr, span))


    def handle_expreval(self, expr, span):
        self._curnode.append(('expreval', expr, span))
        

    def handle_comment(self, span):
        self._curnode.append(('comment', span))
        

    def handle_text(self, txt, span):
        self._curnode.append(('txt', txt, span))

    
    def handle_mute(self, span):
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('mute', None, [span]))


    def handle_endmute(self, span):
        directive, dummy, spans = self._open_blocks.pop(-1)
        spans.append(span)
        block = (directive, self._curnode, spans)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    @property
    def tree(self):
        return self._tree


class Renderer:
    
    def __init__(self, evaluator=None, synclines=False, linelength=0):
        self._evaluator = Evaluator() if evaluator is None else evaluator
        self._curfile = None
        self._active_macros = []
        self.synclines = synclines
        self._linelength = linelength


    def render(self, tree, env=None):
        output, eval_inds, eval_pos = self._render(tree, env)
        if eval_inds:
            self._postprocess_expreval_lines(output, eval_inds, eval_pos)
        return ''.join(output)


    def _render(self, tree, env=None):
        newscope = env is not None
        if newscope:
            self._evaluator.pushenv(env)
        output = []
        eval_inds = []
        eval_pos = []
        for node in tree:
            cmd = node[0]
            if cmd == 'txt':
                output.append(node[1])
            elif cmd == 'if':
                out, ieval, peval = self._get_conditional_content(*node[1:4])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'expreval':
                out, ieval, peval = self._get_expreval(*node[1:3])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'macrodef':
                result = self._define_macro(*node[1:5])
                output.append(result)
            elif cmd == 'setvar':
                result = self._define_variable(*node[1:4])
                output.append(result)
            elif cmd == 'for':
                out, ieval, peval = self._get_iterated_content(*node[1:5])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'include':
                result = self._register_file(*node[1:3])
                output.append(result)
            elif cmd == 'comment':
                output.append(self._get_comment(*node[1:2]))
            elif cmd == 'mute':
                output.append(self._get_muted_content(*node[1:3]))
            else:
                result = '<<<< INVALID LINE |' + cmd + '|\n'
                output.append(result)
        if newscope:
            self._evaluator.popenv()
        return output, eval_inds, eval_pos


    def _get_expreval(self, expr, span):
        self._update_linenr(span[1])
        out = [ str(self._evaluator.evaluate(expr)) ]
        if not self._active_macros:
            ieval = [ 0 ]
            peval = [ (span, self._curfile) ]
        else:
            ieval = []
            peval = []
        return out, ieval, peval


    def _get_conditional_content(self, conditions, contents, spans):
        out = []
        ieval = []
        peval = []
        multiline = (spans[0][0] != spans[-1][1])
        for condition, content, span in zip(conditions, contents, spans):
            self._update_linenr(span[1])
            if self._evaluator.evaluate(condition):
                if self.synclines and not self._active_macros and multiline:
                    out.append(syncline(span[1], self._curfile))
                outcont, ievalcont, pevalcont = self._render(content)
                ieval += _shiftinds(ievalcont, len(out))
                peval += pevalcont
                out += outcont
                break
        if self.synclines and not self._active_macros and multiline:
            out.append(syncline(spans[-1][1], self._curfile))
        return out, ieval, peval


    def _get_iterated_content(self, loopvars, loopiter, content, spans):
        out = []
        ieval = []
        peval = []
        self._update_linenr(spans[0][1])
        iterobj = iter(self._evaluator.evaluate(loopiter))
        multiline = (spans[0][0] != spans[-1][1])
        for var in iterobj:
            if len(loopvars) == 1:
                loopscope = {loopvars[0]: var}
            else:
                loopscope = {varname: value 
                             for varname, value in zip(loopvars, var)}
            if self.synclines and not self._active_macros and multiline:
                out.append(syncline(spans[0][1], self._curfile))
            outcont, ievalcont, pevalcont = self._render(content, loopscope)
            ieval += _shiftinds(ievalcont, len(out))
            peval += pevalcont
            out += outcont
        if self.synclines and not self._active_macros and multiline:
            out.append(syncline(spans[1][1], self._curfile))
        return out, ieval, peval


    def _define_macro(self, name, args, content, spans):
        result = ''
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID MACRO NAME {}'.format(name))
            return result
        macro = _Macro(name, args, content, self.render, self._open_macro,
                       self._close_macro)
        self._evaluator.define(name, macro)
        multiline = (spans[0][0] != spans[-1][1])
        if self.synclines and not self._active_macros:
            result = syncline(spans[1][1], self._curfile)
        return result


    def _define_variable(self, name, valstr, span):
        result = ''
        if name.startswith(_RESERVED_PREFIX):
            print('<<< INVALID VARIABLE NAME')
            return result
        self._update_linenr(span[0])
        self._evaluator.setvar(name, valstr)
        multiline = (span[0] != span[1])
        if self.synclines and not self._active_macros and multiline:
            result = syncline(span[1], self._curfile)
        return result


    def _get_comment(self, span):
        if self.synclines and not self._active_macros:
            return syncline(span[1], self._curfile)
        else:
            return ''


    def _get_muted_content(self, content, spans):
        self._render(content)
        if self.synclines and not self._active_macros:
            return syncline(spans[-1][1], self._curfile)
        else:
            return ''

    
    def _open_macro(self, name):
        self._active_macros.append(name)
        
    
    def _close_macro(self, name):
        active_name = self._active_macros.pop(-1)
        if active_name != name:
            print('<<< INTERNAL ERROR: MISMATCHING MACRO CLOSING')


    def _register_file(self, fname, line):
        result = ''
        self._curfile = fname
        self._evaluator.updateenv(__FILE__=fname)
        if self.synclines and not self._active_macros:
            result = syncline(line, self._curfile)
        return result


    def _update_linenr(self, linenr):
        if not self._active_macros:
            self._evaluator.updateenv(__LINE__=linenr + 1) 


    def _postprocess_expreval_lines(self, output, eval_inds, eval_pos):
        lastproc = -1
        for ii, ind in enumerate(eval_inds):
            span, fname = eval_pos[ii]
            if ind <= lastproc:
                continue

            # find last eol before expr. evaluation
            iprev = ind - 1
            while iprev >= 0:
                eolprev = output[iprev].rfind('\n')
                if eolprev != -1:
                    break
                iprev -= 1
            else:
                iprev = 0
                eolprev = -1
                
            # find first eol after expr. evaluation
            inext = ind + 1
            while inext < len(output):
                eolnext = output[inext].find('\n')
                if eolnext != -1:
                    break
                inext += 1
            else:
                inext = len(output) - 1
                eolnext = len(output[-1]) - 1

            # Create full line containing the evaluated expression
            curline_parts = []
            if iprev != ind:
                curline_parts = [ output[iprev][eolprev + 1:] ]
                output[iprev] = output[iprev][:eolprev + 1]
            curline_parts.extend(output[iprev + 1:ind])
            curline_parts.extend(output[ind])
            curline_parts.extend(output[ind + 1:inext])
            if inext != ind:
                curline_parts.append(output[inext][:eolnext + 1])
                output[inext] = output[inext][eolnext + 1:]
            curline = ''.join(curline_parts)
            output[iprev + 1:inext] = [ '' ] * (inext - iprev - 1)
            
            # Split lines and add synclines if needed
            lines = self._splitlines(curline)
            # if curline ended with '\n', last element of lines is ''
            nrlines = len(lines) if lines[-1] else len(lines) - 1
            if self.synclines and (nrlines > 1 or span[0] != span[1]):
                oldlines = lines
                syncl = syncline(span[0], fname)
                lines = [ oldlines[0] + '\n' ]
                for line in oldlines[1:-1]:
                    lines.append(syncl)
                    lines.append(line + '\n')
                if oldlines[-1]:
                    # Line did not end on '\n' -> it was last line of input
                    # -> no syncline is needed.
                    lines.append(oldlines[-1])
                elif span[0] != span[1]:
                    # Syncline needed, if expression evaluation goes
                    # over multiple lines. Otherwise the syncline inserted
                    # before the last line of the evaluation (pointing to
                    # the line of the directive) ensures correct line numbering
                    # for the following content.
                    lines.append(syncline(span[1] + 1, fname))
                output[ind] = ''.join(lines)
            else:
                output[ind] = '\n'.join(lines)
            lastproc = inext


    def _splitlines(self, line):
        lines = line.split('\n')
        result = []
        for line in lines:
            result += _split_line(line, self._linelength)
        return result


class Evaluator:

    RESTRICTED_BUILTINS = {
        'abs': builtins.abs,
        'all': builtins.all,
        'any': builtins.any,
        'ascii': builtins.ascii,
        'bin': builtins.bin,
        'bool': builtins.bool,
        'bytearray': builtins.bytearray,
        'bytes': builtins.bytes,
        'callable': builtins.callable,
        'chr': builtins.chr,
        'classmethod': builtins.classmethod,
        'complex': builtins.complex,
        'delattr': builtins.delattr,
        'dict': builtins.dict,
        'dir': builtins.dir,
        'divmod': builtins.divmod,
        'enumerate': builtins.enumerate,
        'filter': builtins.filter,
        'float': builtins.float,
        'format': builtins.format,
        'frozenset': builtins.frozenset,
        'getattr': builtins.getattr,
        'globals': builtins.globals,
        'hasattr': builtins.hasattr,
        'hash': builtins.hash,
        'hex': builtins.hex,
        'id': builtins.id,
        'int': builtins.int,
        'isinstance': builtins.isinstance,
        'issubclass': builtins.issubclass,
        'iter': builtins.iter,
        'len': builtins.len,
        'list': builtins.list,
        'locals': builtins.locals,
        'map': builtins.map,
        'max': builtins.max,
        'memoryview': builtins.memoryview,
        'min': builtins.min,
        'next': builtins.next,
        'object': builtins.object,
        'oct': builtins.oct,
        'ord': builtins.ord,
        'pow': builtins.pow,
        'property': builtins.property,
        'range': builtins.range,
        'repr': builtins.repr,
        'reversed': builtins.reversed,
        'round': builtins.round,
        'set': builtins.set,
        'setattr': builtins.setattr,
        'slice': builtins.slice,
        'sorted': builtins.sorted,
        'staticmethod': builtins.staticmethod,
        'str': builtins.str,
        'sum': builtins.sum,
        'super': builtins.super,
        'tuple': builtins.tuple,
        'type': builtins.type,
        'vars': builtins.vars,
        'zip': builtins.zip,
    }

    def __init__(self, env=None, restricted=True):
        self._env = env.copy() if env is not None else {}
        self._envstack = []
        if restricted:
            builtindict = {}
            builtindict.update(self.RESTRICTED_BUILTINS)
            builtindict['__import__'] = self._func_import
        else:
            builtindict = vars(builtins)
        builtindict['defined'] = self._func_defined
        builtindict['setvar'] = self._func_setvar
        builtindict['default'] = self._func_default
        self._builtins = {'__builtins__': builtindict}


    def evaluate(self, expr):
        result = eval(expr, self._builtins, self._env)
        return result


    def execute(self, code):
        exec(code, self._builtins, self._env)


    def setvar(self, name, valstr):
        value = self.evaluate(valstr)
        self.define(name, value)


    def define(self, name, value):
        self._env[name] = value

    
    def updateenv(self, **vardict):
        self._env.update(vardict)


    def pushenv(self, vardict):
        self._envstack.append(self._env)
        self._env = self._env.copy()
        self._env.update(vardict)


    def popenv(self):
        self._env = self._envstack.pop(-1)

    
    @property
    def env(self):
        return self._env


    def _func_defined(self, var):
        return var in self._env

    
    def _func_import(self, name, *_, **__):
        module = self._env.get(name, None)
        if module is not None and isinstance(module, types.ModuleType):
            return module
        else:
            msg = "Import of module '{}' via '__import__' not allowed" \
                  .format(name)
            raise ImportError(msg)
        return ''


    def _func_setvar(self, name, value):
        self.setvar(name, value)
        return ''


    def _func_default(self, name, defvalue):
        if name in self._env:
            return self._env[name]
        else:
            return defvalue


class _Macro:

    def __init__(self, name, argnames, content, renderfunc, openfunc, 
                 closefunc):
        self._name = name
        self._argnames = argnames
        self._content = content
        self._renderfunc = renderfunc
        self._openfunc = openfunc
        self._closefunc = closefunc


    def __call__(self, *args, **keywords):
        self._openfunc(self._name)
        if len(args) != len(self._argnames):
            print('<<< INVALID NR OF ARGS')
        argdict = {}
        for argname, arg in zip(self._argnames, args):
            argdict[argname] = arg
        argdict.update(keywords)
        output = self._renderfunc(self._content, argdict)
        self._closefunc(self._name)
        return output.rstrip()


class Processor:

    def __init__(self, parser=None, builder=None, renderer=None,
                 evaluator=None):
        self._parser = DirectiveParser() if parser is None else parser
        self._builder = TreeBuilder() if builder is None else builder
        if renderer is None:
            evaluator = Evaluator() if evaluator is None else evaluator
            self._renderer = Renderer(evaluator)
        else:
            self._renderer = renderer

        self._parser.handle_open_file = self._builder.handle_open_file
        self._parser.handle_if = self._builder.handle_if
        self._parser.handle_else = self._builder.handle_else
        self._parser.handle_elif = self._builder.handle_elif
        self._parser.handle_endif = self._builder.handle_endif
        self._parser.handle_expreval = self._builder.handle_expreval
        self._parser.handle_text = self._builder.handle_text
        self._parser.handle_def = self._builder.handle_def
        self._parser.handle_enddef = self._builder.handle_enddef
        self._parser.handle_setvar = self._builder.handle_setvar
        self._parser.handle_for = self._builder.handle_for
        self._parser.handle_endfor = self._builder.handle_endfor
        self._parser.handle_comment = self._builder.handle_comment
        self._parser.handle_mute = self._builder.handle_mute
        self._parser.handle_endmute = self._builder.handle_endmute


    def process_file(self, fname, env=None):
        self._parser.parsefile(fname)
        return self._render(env)


    def process_text(self, txt, env=None):
        self._parser.parse(txt)
        return self._render(env)


    def _render(self, env):
        env = {} if env is None else env
        output = self._renderer.render(self._builder.tree, env)
        self._builder.reset()
        return ''.join(output)


def syncline(linenr, fname):
    return '# {} "{}"\n'.format(linenr + 1, fname)


def _split_line(line, maxlen):
    if len(line) <= maxlen:
        result = [ line ]
    else:
        result = [line[:maxlen - 1] + '&']
        maxlen4 = maxlen - 4
        pos = maxlen - 1 - maxlen4
        for pos in range(maxlen - 1, len(line) - maxlen4 - 1, maxlen4):
            result.append('  &' + line[pos:pos + maxlen4] + '&')
        result.append('  &' + line[pos + maxlen4:])
    return result


def _shiftinds(inds, shift):
    return [ ind + shift for ind in inds ]
    

################################################################################
# Command line tool
################################################################################

_FYPP_DESC= '''Preprocess Fortran source files with FYPP directives.'''


class Fypp:

    def __init__(self, cmdline_args=None):
        self._argparser = self._get_cmdline_parser()
        self._args = self._argparser.parse_args(cmdline_args)
        errorfunc = self._argparser.error
        inieval = Evaluator(restricted=False)
        if self._args.modules:
            self._import_modules(self._args.modules, inieval, errorfunc)
        if self._args.inifiles:
            self._exec_inifiles(self._args.inifiles, inieval, errorfunc)
        evaluator = Evaluator(env=inieval.env, restricted=True)
        if self._args.defines:
            self._apply_definitions(self._args.defines, evaluator, errorfunc)
        parser = DirectiveParser(self._args.includes)
        builder = TreeBuilder()
        renderer = Renderer(evaluator, synclines=self._args.synclines,
                            linelength=self._args.line_length)
        self._preprocessor = Processor(parser, builder, renderer)


    def process_cmdline_files(self, env=None):
        infile = STDIN if self._args.infile == '-' else self._args.infile
        output = self._preprocessor.process_file(infile, env)
        if self._args.outfile == '-':
            fp = sys.stdout
        else:
            fp = open(self._args.outfile, 'w')
        fp.write(output)
        if fp != sys.stdout:
            fp.close()


    def process_text(self, txt, env=None):
        return self._preprocessor.process_text(txt, env)


    @staticmethod
    def _get_cmdline_parser():
        parser = ArgumentParser(description=_FYPP_DESC)
        msg = 'define variable. Value is interpreted as ' \
              'Python expression (e.g \'-DDEBUG=1\' sets DEBUG to the ' \
              'integer 1) or set to None if ommitted.'
        parser.add_argument('-D', '--define', action='append', dest='defines',
                            metavar='VAR[=VALUE]', help=msg)
        msg = 'add directory to the search paths for include files'
        parser.add_argument('-I', '--include', action='append', dest='includes',
                            metavar='INCDIR', help=msg)
        msg = 'include CPP style sync-lines in the output'
        parser.add_argument('-s', '--synclines', action='store_true',
                            default=False, help=msg)
        msg = 'maximal line length (default: 132). Lines modified by the ' \
              'preprocessor will be folded to this length. Setting to 0 ' \
              'disables line folding.'
        parser.add_argument('-l', '--line-length', type=int, default=132,
                            metavar='LEN', help=msg)
        msg = 'import python module before starting the processing'
        parser.add_argument('-m', '--module', action='append', dest='modules',
                            metavar='MOD', help=msg)
        msg = 'execute python initialization script before starting processing'
        parser.add_argument('-i', '--ini-file', action='append', 
                            dest='inifiles', metavar='INI', help=msg)
        versionstr = '%(prog)s ' + VERSION
        parser.add_argument('-v', '--version', action='version',
                            version=versionstr)
        msg = "input file to be processed (default: '-', stdin)"
        parser.add_argument('infile', nargs='?', default='-', help=msg)
        msg = "output file where processed content will be written (default: " \
              "'-', stdout)"
        parser.add_argument('outfile', nargs='?', default='-', help=msg)
        return parser


    @staticmethod
    def _apply_definitions(defines, evaluator, errorfunc):
        for define in defines:
            words = define.split('=', 2)
            name = words[0]
            value = None
            if len(words) > 1:
                try:
                    value = evaluator.evaluate(words[1])
                except Exception as ex:
                    msg = "Exception at evaluating '{}' in definition for " \
                          "'{}':\n{}".format(words[1], name, ex)
                    errorfunc(msg)
            evaluator.define(name, value)


    @staticmethod
    def _import_modules(modules, evaluator, errorfunc):
        for module in modules:
            try:
                evaluator.execute('import ' + module)
            except Exception as ex:
                msg = "Exception occured during import of module '{}':\n{}"\
                      .format(module, ex)
                errorfunc(msg)

    
    @staticmethod
    def _exec_inifiles(inifiles, evaluator, errorfunc):
        for inifile in inifiles:
            try:
                fp = open(inifile, 'r')
                code = fp.read()
                fp.close()
            except IOError as ex:
                msg = "IO error occured at reading file '{}':\n{}"\
                    .format(inifile, ex)
                errorfunc(msg)
            try:
                evaluator.execute(code)
            except Exception as ex:
                msg = "Exception occured when executing ini-file '{}':\n{}"\
                      .format(inifile, ex)
                errorfunc(msg)


if __name__ == '__main__':
    tool = Fypp()
    tool.process_cmdline_files()
