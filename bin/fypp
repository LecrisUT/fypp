#!/usr/bin/env python3
################################################################################
#
# fypp -- Python powered Fortran preprocessor
#
# Copyright (c) 2016, BÃ¡lint Aradi
#
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
################################################################################

'''The functionality of the FYPP preprocessor is realized using following
classes:

* `Parser`_: Reads a source file, does basic syntax checking and generates
  events.

* `Builder`_: Builds a tree representation of the source file by
  receiving events. Does additional syntax checking.

* `Renderer`_: Renders a tree built by the builder.

* `Evaluator`_: Evaluates Python expressions in a designated environment. It is 
  used by the Renderer when rendering eval directives.

* `Processor`_: Connects `Parser`, `Builder`, `Renderer` and `Evaluator` with
  each other and returns for a given input the preprocessed output.

* `Fypp`_: Command line preprocessor. Drives `Processor` according to the
  command line arguments.

If any expected error occurs during processing, `FyppError`_ is raised.
'''

import builtins
import types
import re
import os
import sys
import time
from argparse import ArgumentParser


VERSION = '1.0'

STDIN = '<stdin>'

FILEOBJ = '<fileobj>'

STRING = '<string>'


_DIRECTIVE_REGEXP = re.compile(r'''
# comment block
(?P<comment>(?:^[ \t]*@!.*\n)+)
|
# line directive (with optional continuation lines)
^[ \t]*@:[ \t]*(?P<ldirective>\w+)[ \t]*
(?P<lparam>.*?(?:&[ \t]*\n[ \t]*&.*?)*)?[ \t]*\n
|
# line expression evaluation (with optional continuation lines)
^[ \t]*\$:[ \t]*(?P<lexpr>.*?(?:&[ \t]*\n(?:[ \t]*&)?.*?)*)[ \t]*$
|
# inline directive
@\{[ \t]*(?P<idirective>\w+)[ \t]*(?P<param>.*?)?[ \t]*\}@
|
# inline expression evaluation
\$\{[ \t]*(?P<iexpr>.*?)[ \t]*\}\$
''', re.VERBOSE | re.MULTILINE)

_MACRO_PARAM_REGEXP = re.compile(
    r'^(?P<name>\w+)\((?P<args>\s*(?:\w+\s*,\s*)*(?:\w+)\s*)\)$')

_SETVAR_PARAM_REGEXP = re.compile(r'^(?P<name>\w+)(?:\s+(?P<expr>.*))?\s*$')

_FOR_PARAM_REGEXP = re.compile(
    r'^(?P<loopexpr>\w+(\s*,\s*\w+)*)\s+in\s+(?P<iter>.+)\s*$')

_INCLUDE_PARAM_REGEXP = re.compile(r'^(\'|")(?P<fname>.*?)\1\s*$')

_CONTLINE_REGEXP = re.compile(r'&[ \t]*\n(?:[ \t]*&)?')

_UNESCAPE_REGEXP1 = re.compile(r'([$@])\\(\\*)([{:])')

_UNESCAPE_REGEXP2 = re.compile(r'(\})\\(\\*)([$@])')

_RESERVED_PREFIX = '__'

_RESERVED_NAMES = ('defined', 'setvar', 'getvar', '_LINE_', '_FILE_', 
                   '_TIME_', '_DATE_')


class FyppError(Exception):
    '''Signalizes error occuring during preprocessing.
    
    Args:
        msg (str): Error message.
        fname (str): File name. None (default) if file name is not available.
        span (tuple of int): Beginning and end line of the region where error
            occured or None if not available.
    
    
    Attributes:
        msg (str): Error message.
        fname (str or None): File name or None if not available.
        span (tuple of int or None): Beginning and end line of the region
            where error occured or None if not available. Line numbers start
            from zero. For directives, which do not consume end of the line,
            start and end lines are identical.
    '''
    
    def __init__(self, msg, fname=None, span=None):
        self.msg = msg
        self.fname = fname
        self.span = span


    def __str__(self):
        msg = [ self.__class__.__name__, ':\n' ]
        if self.fname is not None:
            msg.append("file '" + self.fname + "'")
            if self.span is not None:
                if self.span[1] > self.span[0] + 1:
                    msg.append(', lines {}-{}'.format(
                        self.span[0] + 1, self.span[1]))
                else:
                    msg.append(', line {}'.format(self.span[0] + 1))
            msg.append('\n')
        if self.msg:
            msg.append(self.msg)
        return ''.join(msg)


class Parser:
    '''Parses a text and generates events when encountering FYPP constructs.

    Args:
        includedirs (list): List of directories, in which include files should
            be searched for, when they are not found in the default location.
    '''

    def __init__(self, includedirs=None):
        if includedirs is None:
            self._includedirs = []
        else:
            self._includedirs = includedirs
        self._curfile = None
        self._curdir = None


    def parsefile(self, fobj):
        '''Parses file or a file like object.

        Args:
            fobj (str or file): Name of a file or a file like object.
        '''
        closefile = False
        if isinstance(fobj, str):
            if fobj == STDIN:
                fp = sys.stdin
                self._curfile = fobj
                self._curdir = os.getcwd()
            else:
                fp = open(fobj, 'r')
                closefile = True
                self._curfile = fobj
                self._curdir = os.path.dirname(fobj)
        else:
            fp = fobj
            self._curfile = FILEOBJ
            self._curdir = os.getcwd()
        self.handle_open_file((0, 0), self._curfile)
        self._parse(fp.read())
        self.handle_close_file((-1, -1), self._curfile )
        if closefile:
            fp.close()


    def parse(self, txt):
        '''Parses string.

        Args:
            txt (str): Text to parse.
        '''
        self._curfile = STRING
        self._curdir = os.getcwd()
        self.handle_open_file((0, 0), self._curfile)
        self._parse(txt)
        self.handle_close_file((-1, -1), self._curfile)

    
    def handle_open_file(self, span, fname):
        '''Called when parser starts to parse a new file.
        
        It is a dummy methond and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            fname (str): Name of the file.
        '''
        self._log_event('open file', span, filename=fname)


    def handle_close_file(self, span, fname):
        '''Called when parser finished processing a file.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            fname (str): Name of the file.
        '''
        self._log_event('close file', span, filename=fname)

        
    def handle_setvar(self, span, name, expr):
        '''Called when parser encounters a setvar directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            name (str): Name of the variable.
            expr (str): String representation of the expression to be assigned
                to the variable.
        '''
        self._log_event('setvar', span, name=name, expression=expr)

    
    def handle_def(self, span, name, args):
        '''Called when parser encounters a def directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            name (str): Name of the macro to be defined.
            args (list of str): Name of the macro arguments.
        '''
        self._log_event('def', span, name=name, arguments=args)


    def handle_enddef(self, span):
        '''Called when parser encounters an enddef directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('enddef', span)


    def handle_if(self, span, cond):
        '''Called when parser encounters an if directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            cond (str): String representation of the branching condition.
        '''
        self._log_event('if', span, condition=param)


    def handle_elif(self, span, cond):
        '''Called when parser encounters an elif directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            cond (str): String representation of the branching condition.
        '''
        self._log_event('elif', span, condition=param)


    def handle_else(self, span):
        '''Called when parser encounters an else directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('else', span)

        
    def handle_endif(self, span):
        '''Called when parser encounters an endif directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('endif', span)


    def handle_for(self, span, varexpr, iterator):
        '''Called when parser encounters a for directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            varexpr (str): String representation of the loop variable 
                expression.
            iterator (str): String representation of the iterable.
        '''
        self._log_event('for', span, variable=varexpr, iterable=iterator)


    def handle_endfor(self, span):
        '''Called when parser encounters an endfor directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('endfor', span)


    def handle_eval(self, span, expr):
        '''Called when parser encounters an eval directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            expr (str): String representation of the Python expression to
                be evaluated.
        '''
        self._log_event('eval', span, expression=expr)


    def handle_text(self, span, txt):
        '''Called when parser finds text which must left unaltered.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
            txt (str): Text.
        '''
        self._log_event('text', span, content=txt)


    def handle_comment(self, span):
        '''Called when parser finds a preprocessor comment.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('comment', span)


    def handle_mute(self, span):
        '''Called when parser finds a mute directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('mute', span)

    
    def handle_endmute(self, span):
        '''Called when parser finds an endmute directive.
        
        It is a dummy method and should be overriden for actual use.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._log_event('endmute', span)


    @staticmethod
    def _log_event(event, span, **params):
        print('{}: {} --> {}'.format(event, span[0], span[1]))
        for parname, parvalue in params.items():
            print('  {}: ->|{}|<-'.format(parname, parvalue))
        print()

        
    def _parse(self, txt):
        pos = 0
        linenr = 0
        for match in _DIRECTIVE_REGEXP.finditer(txt):
            groups = match.groupdict()
            start, end = match.span()
            if start > pos:
                endlinenr = linenr + txt.count('\n', pos, start)
                self.handle_text((linenr, endlinenr), txt[pos:start])
                linenr = endlinenr
            endlinenr = linenr + txt.count('\n', start, end)
            if groups['ldirective'] is not None:
                self._process_directive(
                    groups['ldirective'], groups['lparam'], 
                    (linenr, endlinenr))
            elif groups['lexpr'] is not None:
                self._process_lexpreval(groups['lexpr'], (linenr, endlinenr))
            elif groups['idirective'] is not None:
                self._process_directive(groups['idirective'], groups['param'],
                                        (linenr, endlinenr))
            elif groups['iexpr'] is not None:
                self._process_iexpreval(groups['iexpr'], (linenr, endlinenr))
            elif groups['comment'] is not None:
                self.handle_comment((linenr, endlinenr))
            else:
                msg = 'internal error: unknown matching pattern'
                raise FyppError(msg, self._curfile, (linenr, endlinenr))
            pos = end
            linenr = endlinenr
        if pos < len(txt):
            endlinenr = linenr + txt.count('\n', pos)
            self.handle_text((linenr, endlinenr), txt[pos:])


    def _process_directive(self, directive, param, span):
        param = _CONTLINE_REGEXP.sub('', param)
        if directive == 'if':
            self.handle_if(span, param)
        elif directive == 'else':
            self._check_empty_param('else', param, span)
            self.handle_else(span)
        elif directive == 'elif':
            self.handle_elif(span, param)
        elif directive == 'endif':
            self._check_empty_param('endif', param, span)
            self.handle_endif(span)
        elif directive == 'def':
            self._process_def(param, span)
        elif directive == 'enddef':
            self._check_empty_param('enddef', param, span)
            self.handle_enddef(span)
        elif directive == 'setvar':
            self._process_setvar(param, span)
        elif directive == 'for':
            self._process_for(param, span)
        elif directive == 'endfor':
            self._check_empty_param('endfor', param, span)
            self.handle_endfor(span)
        elif directive == 'include':
            self._check_not_inline_directive('include', span)
            self._process_include(param, span)
        elif directive == 'mute':
            self._check_empty_param('mute', param, span)
            self._check_not_inline_directive('mute', span)
            self.handle_mute(span)
        elif directive == 'endmute':
            self._check_empty_param('endmute', param, span)
            self._check_not_inline_directive('endmute', span)
            self.handle_endmute(span)
        else:
            msg = "unknown directive '{}'".format(directive)
            raise FyppError(msg, self._curfile, span)

            
    def _process_lexpreval(self, expr, span):
        expr = _CONTLINE_REGEXP.sub('', expr)
        self.handle_eval(span, expr)


    def _process_iexpreval(self, expr, span):
        self.handle_eval(span, expr)


    def _process_def(self, param, span):
        match = _MACRO_PARAM_REGEXP.search(param)
        if not match:
            msg = "invalid macro definition '{}'".format(param)
            raise FyppError(msg, self._curfile, span)
        name = match.group('name')
        argstr = match.group('args')
        args = [s.strip() for s in argstr.split(',')]
        self.handle_def(span, name, args)
        

    def _process_setvar(self, param, span):
        match = _SETVAR_PARAM_REGEXP.search(param)
        if not match:
            msg = "invalid variable assignment '{}'".format(param)
            raise FyppError(msg, self._curfile, span)
        self.handle_setvar(span, match.group('name'), match.group('expr'))


    def _process_for(self, param, span):
        match = _FOR_PARAM_REGEXP.search(param)
        if not match:
            msg = "invalid for loop declaration '{}'".format(param)
            raise FyppError(msg, self._curfile, span)
        loopexpr = match.group('loopexpr')
        loopvars = [s.strip() for s in loopexpr.split(',')]
        self.handle_for(span, loopvars, match.group('iter'))

        
    def _process_include(self, param, span):
        match = _INCLUDE_PARAM_REGEXP.search(param)
        if not match:
            msg = "invalid include declaration '{}'".format(param)
            raise FyppError(msg, self._curfile, span)
        fname = match.group('fname')
        for incdir in [ self._curdir ] + self._includedirs:
            fpath = os.path.join(incdir, fname)
            if os.path.exists(fpath):
                break
        else:
            msg = "include file '{}' not found".format(fname)
            raise FyppError(msg, self._curfile, span)
        oldfile = self._curfile
        self.parsefile(fpath)
        self._curfile = oldfile
        self.handle_open_file(span, self._curfile)


    def _process_mute(self, span):
        if span[0] == span[1]:
            msg = 'Inline form of mute directive not allowed'
            raise FyppError(msg, self._curfile, span)
        self.handle_mute(span)


    def _process_endmute(self, span):
        if span[0] == span[1]:
            msg = 'Inline form of endmute directive not allowed'
            raise FyppError(msg, self._curfile, span)
        self.handle_endmute(span)


    def _check_empty_param(self, directive, param, span):
        if param.strip():
            msg = 'superfluous data in {} directive'.format(directive)
            raise FyppError(msg, self._curfile, span)

    def _check_not_inline_directive(self, directive, span):
        if span[0] == span[1]:
            msg = 'Inline form of {} directive not allowed'.format(directive)
            raise FyppError(msg, self._curfile, span)


class Builder:
    '''Builds a tree representing a text with preprocessor directives.
    '''

    def __init__(self):
        self._tree = []
        self._path = []
        self._open_files = []
        self._open_blocks = []
        # Nr. of open blocks before current file was opened
        self._nr_prev_blocks = []
        self._curnode = self._tree
        self._curfile = None


    def reset(self):
        '''Resets the builder so that it starts to build a new tree.'''
        self._tree = []
        self._path = []
        self._open_files = []
        self._open_blocks = []
        self._nr_prev_blocks = []
        self._curnode = self._tree
        self._curfile = None


    def handle_open_file(self, span, fname):
        '''Should be called to signalize change to new file.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            fname (str): Name of the file.
        '''
        self._curfile = fname
        self._curnode.append(('include', span, fname))
        self._open_files.append(fname)
        self._nr_prev_blocks.append(len(self._open_blocks))


    def handle_close_file(self, span, fname):
        '''Should be called when processing of a file finished.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            fname (str): Name of the file.
        '''
        oldfname = self._open_files.pop(-1)
        if fname != oldfname:
            msg = 'internal error: mismatching file name in close_file event'\
                  " (expected: '{}', got '{}')".format(oldfname, fname)
            raise FyppError(msg, fname)
        if len(self._open_blocks) > self._nr_prev_blocks[-1]:
            directive, spans = self._open_blocks[-1][0:2]
            msg = '{} directive in line {} still unclosed when reaching end '\
                  'of file'.format(directive, spans[0][0] + 1)
            raise FyppError(msg, self._curfile)
        del self._nr_prev_blocks[-1]
        
            
    def handle_if(self, span, cond):
        '''Should be called to signalize an if directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            param (str): String representation of the branching condition.
        '''
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('if', [span], [cond], []))


    def handle_elif(self, span, cond):
        '''Should be called to signalize an elif directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            cond (str): String representation of the branching condition.
        '''
        self._check_for_open_block(span, 'elif')
        block = self._open_blocks[-1]
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'if', spans[-1], span, 'elif')
        conds, contents = block[2:4]
        conds.append(cond)
        contents.append(self._curnode)
        spans.append(span)
        self._curnode = []


    def handle_else(self, span):
        '''Should be called to signalize an else directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._check_for_open_block(span, 'else')
        block = self._open_blocks[-1]
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'if', spans[-1], span, 'else')
        conds, contents = block[2:4]
        conds.append('True')
        contents.append(self._curnode)
        spans.append(span)
        self._curnode = []


    def handle_endif(self, span):
        '''Should be called to signalize an endif directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._check_for_open_block(span, 'endif')
        block = self._open_blocks.pop(-1)
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'if', spans[-1], span, 'endif')
        conds, contents = block[2:4]
        contents.append(self._curnode)
        spans.append(span)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_for(self, span, loopvar, iterator):
        '''Should be called to signalize a for directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            varexpr (str): String representation of the loop variable 
                expression.
            iterator (str): String representation of the iterable.
        '''
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('for', [span], loopvar, iterator, None))
        

    def handle_endfor(self, span):
        '''Should be called to signalize an endfor directive.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._check_for_open_block(span, 'endfor')
        block = self._open_blocks.pop(-1)
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'for', spans[-1], span, 'endfor')
        loopvar, iterator, dummy = block[2:5]
        spans.append(span)
        block = (directive, spans, loopvar, iterator, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_def(self, span, name, args):
        '''Should be called to signalize a def directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            name (str): Name of the macro to be defined.
            args (list of str): Name of the macro arguments.
        '''
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('def', [span], name, args, None))


    def handle_enddef(self, span):
        '''Should be called to signalize an enddef directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._check_for_open_block(span, 'enddef')
        block = self._open_blocks.pop(-1)
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'def', spans[-1], span, 'enddef')
        name, args, dummy = block[2:5]
        spans.append(span)
        block = (directive, spans, name, args, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    def handle_setvar(self, span, name, expr):
        '''Should be called to signalize a setvar directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            name (str): Name of the variable.
            expr (str): String representation of the expression to be assigned
                to the variable.
        '''
        self._curnode.append(('setvar', span, name, expr))


    def handle_eval(self, span, expr):
        '''Should be called to signalize an eval directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
            expr (str): String representation of the Python expression to
                be evaluated.
        '''
        self._curnode.append(('eval', span, expr))
        

    def handle_comment(self, span):
        '''Should be called to signalize a comment directive.
        
        The content of the comment is not needed by the builder, but it needs
        the span of the comment to generate proper synclines if needed.

        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._curnode.append(('comment', span))
        

    def handle_text(self, span, txt):
        '''Should be called to pass text which goes to output unaltered.
        
        Args:
            span (tuple of int): Start and end line of the text.
            txt (str): Text.
        '''
        self._curnode.append(('txt', span, txt))

    
    def handle_mute(self, span):
        '''Should be called to signalize a mute directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._path.append(self._curnode)
        self._curnode = []
        self._open_blocks.append(('mute', [span], None))


    def handle_endmute(self, span):
        '''Should be called to signalize an endmute directive.
        
        Args:
            span (tuple of int): Start and end line of the directive.
        '''
        self._check_for_open_block(span, 'endmute')
        block = self._open_blocks.pop(-1)
        directive, spans = block[0:2]
        self._check_if_matches_last(directive, 'mute', spans[-1], span,
                                    'endmute')
        spans.append(span)
        block = (directive, spans, self._curnode)
        self._curnode = self._path.pop(-1)
        self._curnode.append(block)


    @property
    def tree(self):
        '''Returns the tree built by the Builder.'''
        return self._tree


    def _check_for_open_block(self, span, directive):
        if not len(self._open_blocks) > self._nr_prev_blocks[-1]:
            msg = 'unexpected {} directive'.format(directive)
            raise FyppError(msg, self._curfile, span)


    def _check_if_matches_last(self, lastdir, curdir, lastspan, curspan, 
                               directive):
        if curdir != lastdir:
            msg = 'mismatching {} directive'.format(directive)
            raise FyppError(msg, self._curfile, curspan)
        inline_last = lastspan[0] == lastspan[1]
        inline_cur = curspan[0] == curspan[1]
        if inline_last != inline_cur:
            if inline_cur:
                msg = 'expecting line form of directive {}'.format(directive)
            else:
                msg = 'expecting inline form of directive {}'.format(directive)
            raise FyppError(msg, self._curfile, curspan)
        elif inline_cur and curspan[0] != lastspan[0]:
            msg = 'inline directives of the same construct must be in the '\
                  'same row'
            raise FyppError(msg, self._curfile, curspan)


class Renderer:

    ''''Renders a tree.

    Args:
        evaluator (Evaluator, optional): Evaluator to use when rendering eval
            directives. If None (default), Evaluator() is used.
        synclines (bool, optional): Whether synclines should be generated,
            defaults to False.
        linelength (int, optional): Maximal line length, above which line 
            folding should be applied. Zero (default) switches off line folding.
    '''
    
    def __init__(self, evaluator=None, synclines=False, linelength=0):
        self._evaluator = Evaluator() if evaluator is None else evaluator
        self._evaluator.updateenv(_DATE_=time.strftime('%Y-%m-%d'),
                                  _TIME_=time.strftime('%H:%M:%S'))
        self._curfile = None
        self._active_macros = []
        self.synclines = synclines
        self._linelength = linelength


    def render(self, tree, env=None):
        '''Renders a tree.
        
        Args:
            tree (fypp-tree): Tree to render.
            env (dict, optional): Dictionary containing additional definitions
                for the evaluator. The definitions are removed from the
                from the evaluator, once the rendering finished.
        
        Returns:
            str: Rendered string.
        '''
        output, eval_inds, eval_pos = self._render(tree, env)
        if eval_inds:
            self._postprocess_eval_lines(output, eval_inds, eval_pos)
        txt = ''.join(output)
        txt = _UNESCAPE_REGEXP1.sub(r'\1\2\3', txt)
        txt = _UNESCAPE_REGEXP2.sub(r'\1\2\3', txt)
        return txt


    def _render(self, tree, env=None):
        newscope = env is not None
        if newscope:
            self._evaluator.pushenv(env)
        output = []
        eval_inds = []
        eval_pos = []
        for node in tree:
            cmd = node[0]
            if cmd == 'txt':
                output.append(node[2])
            elif cmd == 'if':
                out, ieval, peval = self._get_conditional_content(*node[1:4])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'eval':
                out, ieval, peval = self._get_eval(*node[1:3])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'def':
                result = self._define_macro(*node[1:5])
                output.append(result)
            elif cmd == 'setvar':
                result = self._define_variable(*node[1:4])
                output.append(result)
            elif cmd == 'for':
                out, ieval, peval = self._get_iterated_content(*node[1:5])
                eval_inds += _shiftinds(ieval, len(output))
                eval_pos += peval
                output += out
            elif cmd == 'include':
                result = self._register_file(*node[1:3])
                output.append(result)
            elif cmd == 'comment':
                output.append(self._get_comment(*node[1:2]))
            elif cmd == 'mute':
                output.append(self._get_muted_content(*node[1:3]))
            else:
                msg = "internal error: unknown command '{}'".format(cmd)
                raise FyppError(msg, self._curfile)
        if newscope:
            self._evaluator.popenv()
        return output, eval_inds, eval_pos


    def _get_eval(self, span, expr):
        self._update_linenr(span[1])
        try:
            result = self._evaluator.evaluate(expr)
        except Exception as exc:
            msg = "exception occured when evaluating '{}'\n{}".format(expr, exc)
            raise FyppError(msg, self._curfile, span)
        out = []
        ieval = []
        peval = []
        if result is not None:
            out.append(str(result))
            if not self._active_macros:
                ieval.append(0)
                peval.append((span, self._curfile))
        return out, ieval, peval


    def _get_conditional_content(self, spans, conditions, contents):
        out = []
        ieval = []
        peval = []
        multiline = (spans[0][0] != spans[-1][1])
        for condition, content, span in zip(conditions, contents, spans):
            self._update_linenr(span[1])
            try:
                cond = bool(self._evaluator.evaluate(condition))
            except Exception as exc:
                msg = "exception occured when evaluating '{}'\n{}".format(
                    condition, exc)
                raise FyppError(msg, self._curfile, span)
            if cond:
                if self.synclines and not self._active_macros and multiline:
                    out.append(syncline(span[1], self._curfile))
                outcont, ievalcont, pevalcont = self._render(content)
                ieval += _shiftinds(ievalcont, len(out))
                peval += pevalcont
                out += outcont
                break
        if self.synclines and not self._active_macros and multiline:
            out.append(syncline(spans[-1][1], self._curfile))
        return out, ieval, peval


    def _get_iterated_content(self, spans, loopvars, loopiter, content):
        out = []
        ieval = []
        peval = []
        self._update_linenr(spans[0][1])
        try:
            iterobj = iter(self._evaluator.evaluate(loopiter))
        except Exception as exc:
            msg = "exception occured when evaluating '{}'\n{}"\
                .format(loopiter, exc)
            raise FyppError(msg, self._curfile, spans[0])
        multiline = (spans[0][0] != spans[-1][1])
        for var in iterobj:
            if len(loopvars) == 1:
                loopscope = {loopvars[0]: var}
            else:
                loopscope = {varname: value 
                             for varname, value in zip(loopvars, var)}
            if self.synclines and not self._active_macros and multiline:
                out.append(syncline(spans[0][1], self._curfile))
            outcont, ievalcont, pevalcont = self._render(content, loopscope)
            ieval += _shiftinds(ievalcont, len(out))
            peval += pevalcont
            out += outcont
        if self.synclines and not self._active_macros and multiline:
            out.append(syncline(spans[1][1], self._curfile))
        return out, ieval, peval


    def _define_macro(self, spans, name, args, content):
        result = ''
        try:
            macro = _Macro(name, args, content, self.render, self._open_macro,
                           self._close_macro)
            self._evaluator.define(name, macro)
        except Exception as exc:
            msg = "exception occured when defining macro '{}'".format(name)
            raise FyppError(msg, self._curfile, spans[0])
        if self.synclines and not self._active_macros:
            result = syncline(spans[1][1], self._curfile)
        return result


    def _define_variable(self, span, name, valstr):
        result = ''
        self._update_linenr(span[0])
        try:
            self._evaluator.define(name, self._evaluator.evaluate(valstr))
        except Exception as exc:
            msg = "exception occured when setting variable {} to {}\n{}"\
                .format(name, valstr, exc)
            raise FyppError(msg, self._curfile, span)
        multiline = (span[0] != span[1])
        if self.synclines and not self._active_macros and multiline:
            result = syncline(span[1], self._curfile)
        return result


    def _get_comment(self, span):
        if self.synclines and not self._active_macros:
            return syncline(span[1], self._curfile)
        else:
            return ''


    def _get_muted_content(self, spans, content):
        self._render(content)
        if self.synclines and not self._active_macros:
            return syncline(spans[-1][1], self._curfile)
        else:
            return ''

    
    def _open_macro(self, name):
        self._active_macros.append(name)
        
    
    def _close_macro(self, name):
        active_name = self._active_macros.pop(-1)
        if active_name != name:
            msg = "Internal error: mismatching macro name at closing " \
                  "(received '{}', expected '{}')".format(name, active_name)
            raise FyppError(msg, self._curfile)


    def _register_file(self, span, fname):
        result = ''
        self._curfile = fname
        self._evaluator.updateenv(_FILE_=fname)
        if self.synclines and not self._active_macros:
            result = syncline(span[1], self._curfile)
        return result


    def _update_linenr(self, linenr):
        if not self._active_macros:
            self._evaluator.updateenv(_LINE_=linenr + 1) 


    def _postprocess_eval_lines(self, output, eval_inds, eval_pos):
        lastproc = -1
        for ii, ind in enumerate(eval_inds):
            span, fname = eval_pos[ii]
            if ind <= lastproc:
                continue

            # find last eol before expr. evaluation
            iprev = ind - 1
            while iprev >= 0:
                eolprev = output[iprev].rfind('\n')
                if eolprev != -1:
                    break
                iprev -= 1
            else:
                iprev = 0
                eolprev = -1
                
            # find first eol after expr. evaluation
            inext = ind + 1
            while inext < len(output):
                eolnext = output[inext].find('\n')
                if eolnext != -1:
                    break
                inext += 1
            else:
                inext = len(output) - 1
                eolnext = len(output[-1]) - 1

            # Create full line containing the evaluated expression
            curline_parts = []
            if iprev != ind:
                curline_parts = [ output[iprev][eolprev + 1:] ]
                output[iprev] = output[iprev][:eolprev + 1]
            curline_parts.extend(output[iprev + 1:ind])
            curline_parts.extend(output[ind])
            curline_parts.extend(output[ind + 1:inext])
            if inext != ind:
                curline_parts.append(output[inext][:eolnext + 1])
                output[inext] = output[inext][eolnext + 1:]
            curline = ''.join(curline_parts)
            output[iprev + 1:inext] = [ '' ] * (inext - iprev - 1)
            
            # Split lines and add synclines if needed
            lines = self._splitlines(curline)
            # if curline ended with '\n', last element of lines is ''
            nrlines = len(lines) if lines[-1] else len(lines) - 1
            if self.synclines and (nrlines > 1 or span[0] != span[1]):
                oldlines = lines
                syncl = syncline(span[0], fname)
                lines = [ oldlines[0] + '\n' ]
                for line in oldlines[1:-1]:
                    lines.append(syncl)
                    lines.append(line + '\n')
                if oldlines[-1]:
                    # Line did not end on '\n' -> it was last line of input
                    # -> no syncline is needed.
                    lines.append(oldlines[-1])
                elif span[0] != span[1]:
                    # Syncline needed, if expression evaluation goes
                    # over multiple lines. Otherwise the syncline inserted
                    # before the last line of the evaluation (pointing to
                    # the line of the directive) ensures correct line numbering
                    # for the following content.
                    lines.append(syncline(span[1] + 1, fname))
                output[ind] = ''.join(lines)
            else:
                output[ind] = '\n'.join(lines)
            lastproc = inext


    def _splitlines(self, line):
        lines = line.split('\n')
        result = []
        for line in lines:
            result += _split_line(line, self._linelength)
        return result


class Evaluator:

    '''Provides an isolated environment for evaluating Python expressions.

    It can restrict the builtins which can be used within this environment
    to a (hopefully safe) subset. Additionally it defines the functions
    which are provided by the preprocessor for the eval directives.

    Note, that the restricted environment does not allow importing Python
    modules. If you need a restricted environment with modules loaded,
    launch a non-restricted one, load the modules, export its environment
    and launch a restricted one using that environment.
    
    Args:
        env (dict, optional): Initial definitions for the environment, defaults
            to None.
        restricted (bool, optional): Whether the restricted builtins should
            be used. Otherwise all Python builtins are accessible. Defaults to
            `True` (restricted environment.
    '''

    RESTRICTED_BUILTINS = {
        'abs': builtins.abs,
        'all': builtins.all,
        'any': builtins.any,
        'ascii': builtins.ascii,
        'bin': builtins.bin,
        'bool': builtins.bool,
        'bytearray': builtins.bytearray,
        'bytes': builtins.bytes,
        'callable': builtins.callable,
        'chr': builtins.chr,
        'classmethod': builtins.classmethod,
        'complex': builtins.complex,
        'delattr': builtins.delattr,
        'dict': builtins.dict,
        'dir': builtins.dir,
        'divmod': builtins.divmod,
        'enumerate': builtins.enumerate,
        'filter': builtins.filter,
        'float': builtins.float,
        'format': builtins.format,
        'frozenset': builtins.frozenset,
        'getattr': builtins.getattr,
        'globals': builtins.globals,
        'hasattr': builtins.hasattr,
        'hash': builtins.hash,
        'hex': builtins.hex,
        'id': builtins.id,
        'int': builtins.int,
        'isinstance': builtins.isinstance,
        'issubclass': builtins.issubclass,
        'iter': builtins.iter,
        'len': builtins.len,
        'list': builtins.list,
        'locals': builtins.locals,
        'map': builtins.map,
        'max': builtins.max,
        'memoryview': builtins.memoryview,
        'min': builtins.min,
        'next': builtins.next,
        'object': builtins.object,
        'oct': builtins.oct,
        'ord': builtins.ord,
        'pow': builtins.pow,
        'property': builtins.property,
        'range': builtins.range,
        'repr': builtins.repr,
        'reversed': builtins.reversed,
        'round': builtins.round,
        'set': builtins.set,
        'setattr': builtins.setattr,
        'slice': builtins.slice,
        'sorted': builtins.sorted,
        'staticmethod': builtins.staticmethod,
        'str': builtins.str,
        'sum': builtins.sum,
        'super': builtins.super,
        'tuple': builtins.tuple,
        'type': builtins.type,
        'vars': builtins.vars,
        'zip': builtins.zip,
    }

    def __init__(self, env=None, restricted=True):
        self._env = env.copy() if env is not None else {}
        self._envstack = []
        if restricted:
            builtindict = {}
            builtindict.update(self.RESTRICTED_BUILTINS)
            builtindict['__import__'] = self._func_import
        else:
            builtindict = vars(builtins)
        builtindict['defined'] = self._func_defined
        builtindict['setvar'] = self._func_setvar
        builtindict['getvar'] = self._func_getvar
        self._builtins = {'__builtins__': builtindict}


    def evaluate(self, expr):
        '''Evaluate a Python expression using the `eval()` builtin.
        
        Args:
            expr (str): String represantion of the expression.
        
        Return:
            Python object: Result of the expression evaluation.
        '''
        result = eval(expr, self._builtins, self._env)
        return result


    def execute(self, code):
        '''Run Python code using the `exec()` builtin.
        
        Args:
            code (str): Python code to run.
        '''
        exec(code, self._builtins, self._env)


    def define(self, name, value):
        '''Define a Python entity.
        
        Args:
            name (str): Name of the entity.
            value (Python object): Value of the entity.

        Raises:
            FyppError: If name starts with the reserved prefix or if it is a
                reserved name.
        '''
        if name.startswith(_RESERVED_PREFIX):
            msg = "Name '{}' starts with reserved prefix '{}'"\
                .format(name, _RESERVED_PREFIX)
            raise FyppError(msg, None, None)
        if name in _RESERVED_NAMES:
            msg = "Name '{}' is reserved and can not be redefined"\
                .format(name)
            raise FyppError(msg, None, None)
        self._env[name] = value

    
    def updateenv(self, **vardict):
        '''Add variables to the environment.
        
        Args:
            **vardict: variable defintions.
        '''
        self._env.update(vardict)


    def pushenv(self, vardict):
        '''Push current environment to stack, and use its copy with additional
        new defintions instead.
        
        Args:
            vardict (dict): New variables.
        ''' 
        self._envstack.append(self._env)
        self._env = self._env.copy()
        self._env.update(vardict)


    def popenv(self):
        '''Replace current environment with pop last one from stack.'''
        self._env = self._envstack.pop(-1)

    
    @property
    def env(self):
        '''Return current environment.'''
        return self._env


    def _func_defined(self, var):
        return var in self._env

    
    def _func_import(self, name, *_, **__):
        module = self._env.get(name, None)
        if module is not None and isinstance(module, types.ModuleType):
            return module
        else:
            msg = "Import of module '{}' via '__import__' not allowed" \
                  .format(name)
            raise ImportError(msg)


    def _func_setvar(self, name, value):
        self.define(name, value)
        return ''


    def _func_getvar(self, name, defvalue):
        if name in self._env:
            return self._env[name]
        else:
            return defvalue


class _Macro:

    '''Represents a user defined macro.

    Args:
        name (str): Name of the macro.
        argnames (list of str): Macro dummy arguments.
        content (list): Content of the macro as tree.
        renderfunc (function): Function to call when content should be rendered.
            This is typically the corresponding render routine of the Builder.
        openfunc (function): Function to call when macro rendering started.
            This is typically the corresponding render routine of the Builder.
        closefunc (function): Function to call when macro rendering finished.
            This is typically the corresponding render routine of the Builder.
    '''

    def __init__(self, name, argnames, content, renderfunc, openfunc, 
                 closefunc):
        self._name = name
        self._argnames = argnames
        self._content = content
        self._renderfunc = renderfunc
        self._openfunc = openfunc
        self._closefunc = closefunc


    def __call__(self, *args, **keywords):
        self._openfunc(self._name)
        if len(args) != len(self._argnames):
            msg = "Incorrect nr. of positional arguments for macro '{}' " \
                  "(provided: {}, needed: {})".format(
                      self._name, len(args), len(self._argnames))
            raise FyppError(msg)
        argdict = {}
        for argname, arg in zip(self._argnames, args):
            argdict[argname] = arg
        argdict.update(keywords)
        output = self._renderfunc(self._content, argdict)
        self._closefunc(self._name)
        return output.rstrip()


class Processor:

    '''Connects various objects with each other to create a processor.

    Args:
        parser (Parser, optional): Parser to use for parsing text. If None 
            (default), `Parser()` is used.
        builder (Builder, optional): Builder to use for building the tree
            representation of the text. If None (default), `Builder()` is used.
        renderer (Renderer, optional): Renderer to use for rendering the
            output. If None (default), `Renderer()` is used with a default
            Evaluator().
        evaluator (Evaluator, optional): Evaluator to use for evaluating Python
            expressions. If None (default), `Evaluator()` is used.
    '''

    def __init__(self, parser=None, builder=None, renderer=None,
                 evaluator=None):
        self._parser = Parser() if parser is None else parser
        self._builder = Builder() if builder is None else builder
        if renderer is None:
            evaluator = Evaluator() if evaluator is None else evaluator
            self._renderer = Renderer(evaluator)
        else:
            self._renderer = renderer

        self._parser.handle_open_file = self._builder.handle_open_file
        self._parser.handle_close_file = self._builder.handle_close_file
        self._parser.handle_if = self._builder.handle_if
        self._parser.handle_else = self._builder.handle_else
        self._parser.handle_elif = self._builder.handle_elif
        self._parser.handle_endif = self._builder.handle_endif
        self._parser.handle_eval = self._builder.handle_eval
        self._parser.handle_text = self._builder.handle_text
        self._parser.handle_def = self._builder.handle_def
        self._parser.handle_enddef = self._builder.handle_enddef
        self._parser.handle_setvar = self._builder.handle_setvar
        self._parser.handle_for = self._builder.handle_for
        self._parser.handle_endfor = self._builder.handle_endfor
        self._parser.handle_comment = self._builder.handle_comment
        self._parser.handle_mute = self._builder.handle_mute
        self._parser.handle_endmute = self._builder.handle_endmute


    def process_file(self, fname, env=None):
        '''Processeses a file.
        
        Args:
            fname (str): Name of the file to process.
            env (dict): Additional definitons for the evaluator.
        
        Returns:
            str: Processed content.
        '''
        self._parser.parsefile(fname)
        return self._render(env)


    def process_text(self, txt, env=None):
        '''Processes a string.
        
        Args:
            txt (str): Text to process.
            env (dict): Additional definitons for the evaluator.
        
        Returns:
            str: Processed content.
        '''
        self._parser.parse(txt)
        return self._render(env)


    def _render(self, env):
        env = {} if env is None else env
        output = self._renderer.render(self._builder.tree, env)
        self._builder.reset()
        return ''.join(output)


def syncline(linenr, fname):
    '''Returns a syncline directive.
    
    Args:
        linenr (int): Line nr (starting with 0).
        fname (str): File name.
    '''
    return '# {} "{}"\n'.format(linenr + 1, fname)


def _split_line(line, maxlen):
    if len(line) <= maxlen:
        result = [ line ]
    else:
        result = [line[:maxlen - 1] + '&']
        maxlen4 = maxlen - 4
        pos = maxlen - 1 - maxlen4
        for pos in range(maxlen - 1, len(line) - maxlen4 - 1, maxlen4):
            result.append('  &' + line[pos:pos + maxlen4] + '&')
        result.append('  &' + line[pos + maxlen4:])
    return result


def _shiftinds(inds, shift):
    return [ ind + shift for ind in inds ]
    

################################################################################
# Command line tool
################################################################################

_FYPP_DESC = '''Preprocess Fortran source files with FYPP directives.'''


class Fypp:

    '''Represents the FYPP command line tool.
    
    Args:
        cmdline_args (list of str, optional): Command line arguments. If None
            (default), the arguments are read from sys.argv using Argparser.
    '''

    def __init__(self, cmdline_args=None):
        self._argparser = self._get_cmdline_parser()
        self._args = self._argparser.parse_args(cmdline_args)
        inieval = Evaluator(restricted=False)
        if self._args.modules:
            self._import_modules(self._args.modules, inieval)
        if self._args.inifiles:
            self._exec_inifiles(self._args.inifiles, inieval)
        evaluator = Evaluator(env=inieval.env, restricted=True)
        if self._args.defines:
            self._apply_definitions(self._args.defines, evaluator)
        parser = Parser(self._args.includes)
        builder = Builder()
        renderer = Renderer(evaluator, synclines=self._args.synclines,
                            linelength=self._args.line_length)
        self._preprocessor = Processor(parser, builder, renderer)


    def process_cmdline_files(self, env=None):
        '''Processes the input file and write result to the output file which
        were specified as the command line arguments.

        Args:
            env (dict): Additional definitions for the evaluator.
        '''
        infile = STDIN if self._args.infile == '-' else self._args.infile
        output = self._preprocessor.process_file(infile, env)
        if self._args.outfile == '-':
            fp = sys.stdout
        else:
            fp = open(self._args.outfile, 'w')
        fp.write(output)
        if fp != sys.stdout:
            fp.close()


    def process_text(self, txt, env=None):
        '''Processes a string.
        
        Args:
            txt (str): String to process.
        
        Returns:
            str: Processed content.
        '''
        return self._preprocessor.process_text(txt, env)


    @staticmethod
    def _get_cmdline_parser():
        parser = ArgumentParser(description=_FYPP_DESC)
        msg = 'define variable. Value is interpreted as ' \
              'Python expression (e.g \'-DDEBUG=1\' sets DEBUG to the ' \
              'integer 1) or set to None if ommitted.'
        parser.add_argument('-D', '--define', action='append', dest='defines',
                            metavar='VAR[=VALUE]', help=msg)
        msg = 'add directory to the search paths for include files'
        parser.add_argument('-I', '--include', action='append', dest='includes',
                            metavar='INCDIR', help=msg)
        msg = 'include CPP style sync-lines in the output'
        parser.add_argument('-s', '--synclines', action='store_true',
                            default=False, help=msg)
        msg = 'maximal line length (default: 132). Lines modified by the ' \
              'preprocessor will be folded to this length. Setting to 0 ' \
              'disables line folding.'
        parser.add_argument('-l', '--line-length', type=int, default=132,
                            metavar='LEN', help=msg)
        msg = 'import python module before starting the processing'
        parser.add_argument('-m', '--module', action='append', dest='modules',
                            metavar='MOD', help=msg)
        msg = 'execute python initialization script before starting processing'
        parser.add_argument('-i', '--ini-file', action='append', 
                            dest='inifiles', metavar='INI', help=msg)
        versionstr = '%(prog)s ' + VERSION
        parser.add_argument('-v', '--version', action='version',
                            version=versionstr)
        msg = "input file to be processed (default: '-', stdin)"
        parser.add_argument('infile', nargs='?', default='-', help=msg)
        msg = "output file where processed content will be written (default: " \
              "'-', stdout)"
        parser.add_argument('outfile', nargs='?', default='-', help=msg)
        return parser


    @staticmethod
    def _apply_definitions(defines, evaluator):
        for define in defines:
            words = define.split('=', 2)
            name = words[0]
            value = None
            if len(words) > 1:
                try:
                    value = evaluator.evaluate(words[1])
                except Exception as exc:
                    msg = "exception at evaluating '{}' in definition for " \
                          "'{}'\n{}".format(words[1], name, exc)
                    raise FyppError(msg)
            evaluator.define(name, value)


    @staticmethod
    def _import_modules(modules, evaluator):
        for module in modules:
            try:
                evaluator.execute('import ' + module)
            except Exception as ex:
                msg = "exception occured during import of module '{}'\n{}"\
                      .format(module, ex)
                raise FyppError(msg)

    
    @staticmethod
    def _exec_inifiles(inifiles, evaluator):
        for inifile in inifiles:
            try:
                fp = open(inifile, 'r')
                source = fp.read()
                fp.close()
            except IOError as ex:
                msg = "IO error occured at reading file '{}'\n{}"\
                    .format(inifile, ex)
                raise FyppError(msg)
            try:
                code = compile(source, inifile, 'exec', dont_inherit=-1)
                evaluator.execute(code)
            except Exception as ex:
                msg = "exception occured when executing ini-file '{}'\n{}"\
                      .format(inifile, ex)
                raise FyppError(msg)


if __name__ == '__main__':
    try:
        tool = Fypp()
        tool.process_cmdline_files()
    except FyppError as exc:
        sys.stderr.write(str(exc))
        sys.stderr.write('\n')
        sys.exit(1)
